[{"path":"https://alexpate30.github.io/calibmsm/LICENSE.html","id":null,"dir":"","previous_headings":"","what":"MIT License","title":"MIT License","text":"Copyright (c) 2023 calibmsm authors Permission hereby granted, free charge, person obtaining copy software associated documentation files (‚ÄúSoftware‚Äù), deal Software without restriction, including without limitation rights use, copy, modify, merge, publish, distribute, sublicense, /sell copies Software, permit persons Software furnished , subject following conditions: copyright notice permission notice shall included copies substantial portions Software. SOFTWARE PROVIDED ‚Äú‚Äù, WITHOUT WARRANTY KIND, EXPRESS IMPLIED, INCLUDING LIMITED WARRANTIES MERCHANTABILITY, FITNESS PARTICULAR PURPOSE NONINFRINGEMENT. EVENT SHALL AUTHORS COPYRIGHT HOLDERS LIABLE CLAIM, DAMAGES LIABILITY, WHETHER ACTION CONTRACT, TORT OTHERWISE, ARISING , CONNECTION SOFTWARE USE DEALINGS SOFTWARE.","code":""},{"path":"https://alexpate30.github.io/calibmsm/articles/BLR-IPCW-manual-bootstrap.html","id":"data-preperation","dir":"Articles","previous_headings":"","what":"Data preperation","title":"BLR-IPCW-manual-bootstrap","text":"vignette showcases manually apply bootstrap procedure estimate confidence interval BLR-IPCW calibration curves using custom function estimate inverse probability censoring weights. use data European Society Blood Marrow Transplantation (EBMT 2023), contains multistate survival data transplant patients blood cancer. start follow day transplant initial state alive remission. three intermediate events (22: recovery, 33: adverse event, 44: recovery + adverse event), two absorbing states (55: relapse 66: death). data originally made available mstate package (Wreede, Fiocco, Putter 2011). start reminding EBMT (Wreede, Fiocco, Putter 2011; EBMT 2023) validation datasets ebmtcal msebmtcal, predicted transition probabilities state j = 1 made time s = 0 multistate model (tps0). also set time want evaluate transition probabilities t. Please refer Overview vignette detailed description data.","code":"set.seed(101)  library(calibmsm)  data(\"ebmtcal\") head(ebmtcal) #>   id  rec rec.s   ae ae.s recae recae.s  rel rel.s  srv srv.s      year agecl #> 1  1   22     1  995    0   995       0  995     0  995     0 1995-1998 20-40 #> 2  2   29     1   12    1    29       1  422     1  579     1 1995-1998 20-40 #> 3  3 1264     0   27    1  1264       0 1264     0 1264     0 1995-1998 20-40 #> 4  4   50     1   42    1    50       1   84     1  117     1 1995-1998 20-40 #> 5  5   22     1 1133    0  1133       0  114     1 1133     0 1995-1998   >40 #> 6  6   33     1   27    1    33       1 1427     0 1427     0 1995-1998 20-40 #>   proph              match dtcens dtcens_s #> 1    no no gender mismatch    995        1 #> 2    no no gender mismatch    422        0 #> 3    no no gender mismatch   1264        1 #> 4    no    gender mismatch     84        0 #> 5    no    gender mismatch    114        0 #> 6    no no gender mismatch   1427        1  data(\"msebmtcal\") head(msebmtcal) #>   id from to trans Tstart Tstop time status #> 1  1    1  2     1      0    22   22      1 #> 2  1    1  3     2      0    22   22      0 #> 3  1    1  5     3      0    22   22      0 #> 4  1    1  6     4      0    22   22      0 #> 5  1    2  4     5     22   995  973      0 #> 6  1    2  5     6     22   995  973      0  data(\"tps0\") head(tps0) #>   id   pstate1   pstate2    pstate3   pstate4   pstate5   pstate6        se1 #> 1  1 0.1139726 0.2295006 0.08450376 0.2326861 0.1504855 0.1888514 0.01291133 #> 2  2 0.1140189 0.2316569 0.08442692 0.2328398 0.1481977 0.1888598 0.01291552 #> 3  3 0.1136646 0.2317636 0.08274331 0.2325663 0.1504787 0.1887834 0.01289444 #> 4  4 0.1383878 0.1836189 0.07579429 0.2179331 0.1538475 0.2304185 0.01857439 #> 5  5 0.1233226 0.1609740 0.05508100 0.1828176 0.1425950 0.3352099 0.01944967 #> 6  6 0.1136646 0.2317636 0.08462424 0.2305854 0.1505534 0.1888087 0.01289444 #>          se2        se3        se4        se5        se6 j #> 1 0.02369584 0.01257251 0.02323376 0.01648630 0.01601795 1 #> 2 0.02374329 0.01256056 0.02324869 0.01632797 0.01603703 1 #> 3 0.02375770 0.01245752 0.02322375 0.01647890 0.01601525 1 #> 4 0.03004447 0.01462570 0.03018673 0.02124071 0.02416121 1 #> 5 0.03419721 0.01367768 0.03423941 0.02329644 0.03688586 1 #> 6 0.02375770 0.01257276 0.02317348 0.01649531 0.01602438 1  t <- 1826"},{"path":"https://alexpate30.github.io/calibmsm/articles/BLR-IPCW-manual-bootstrap.html","id":"confidence-intervals-for-blr-ipcw-using-internal-bootstrapping-procedure","dir":"Articles","previous_headings":"","what":"Confidence intervals for BLR-IPCW using internal bootstrapping procedure","title":"BLR-IPCW-manual-bootstrap","text":"now remind procedure generating confidence interval, estimate confidence intervals BLR-IPCW calibration curves using internal bootstrapping procedure, done Overview vignette. Resample validation dataset replacement Landmark dataset assessment calibration Calculate inverse probability censoring weights Fit preferred calibration model landmarked dataset (restricted cubic splines loess smoother) Generate observed event probabilities fixed vector predicted transition probabilities (specifically predicted transition probabilities non-bootstrapped landmark validation dataset) code produce calibration curves confidence intervals follows:","code":"dat_calib_blr <-   calib_msm(data_ms = msebmtcal,            data_raw = ebmtcal,            j=1,            s=0,            t = t,            tp_pred = tps0 |>              dplyr::filter(j == 1) |>              dplyr::select(any_of(paste(\"pstate\", 1:6, sep = \"\"))),            calib_type = 'blr',            curve_type = \"rcs\",            rcs_nk = 3,            w_covs = c(\"year\", \"agecl\", \"proph\", \"match\"),            CI = 95,            CI_R_boot = 200) plot(dat_calib_blr, combine = TRUE) #> TableGrob (2 x 1) \"arrange\": 2 grobs #>   z     cells    name              grob #> 1 1 (1-1,1-1) arrange   gtable[arrange] #> 2 2 (2-2,1-1) arrange gtable[guide-box]"},{"path":"https://alexpate30.github.io/calibmsm/articles/BLR-IPCW-manual-bootstrap.html","id":"confidence-intervals-for-blr-ipcw-by-inputting-custom-weights-funciton-into-calibmsm","dir":"Articles","previous_headings":"","what":"Confidence intervals for BLR-IPCW by inputting custom weights funciton into calibmsm","title":"BLR-IPCW-manual-bootstrap","text":"approach accessible, may lead misspecified model weights given user control choice model (Cox model) functional form predictor variables ùêô\\textbf{Z}, continuous variables assumed linear effects hazard, interaction terms. Potential issues using internal process estimating weights exemplified Evaluation--estimation--IPCWs vignette. therefore encourage users explore data produce suitable model estimate weights. Please see Overview vignette definition estimand weights estimate . function estimating weights defined, internal bootstrapping procedure can applied function estimate weights. function must contain parameters calc_weights function, even plan use parameters. parameters specified arguments w. prefix calib_msm. user specified function may also contain extra parameters calc_weights, specified ... argument calib_msm. showcase defining new function calc_weights_manual. example, define calc_weights function. practice, recommend , option allow user specify function estimating weights. Given choice function estimate weights, calibration curve Figure 1, confidence interval similar size.","code":"calc_weights_manual <- calibmsm::calc_weights  dat_calib_blr_w_function <-   calib_msm(data_ms = msebmtcal,            data_raw = ebmtcal,            j=1,            s=0,            t = t,            tp_pred = tps0 |>              dplyr::filter(j == 1) |>              dplyr::select(any_of(paste(\"pstate\", 1:6, sep = \"\"))),            calib_type = 'blr',            curve_type = \"rcs\",            rcs_nk = 3,            w_function = calc_weights_manual,            w_covs = c(\"year\", \"agecl\", \"proph\", \"match\"),            CI = 95,            CI_R_boot = 200) plot(dat_calib_blr_w_function, combine = TRUE, nrow = 2, ncol = 3) #> TableGrob (2 x 1) \"arrange\": 2 grobs #>   z     cells    name              grob #> 1 1 (1-1,1-1) arrange   gtable[arrange] #> 2 2 (2-2,1-1) arrange gtable[guide-box]"},{"path":"https://alexpate30.github.io/calibmsm/articles/BLR-IPCW-manual-bootstrap.html","id":"confidence-intervals-for-blr-ipcw-by-manually-running-bootstrapping-procedure-with-custom-function-for-estimating-the-weights","dir":"Articles","previous_headings":"","what":"Confidence intervals for BLR-IPCW by manually running bootstrapping procedure with custom function for estimating the weights","title":"BLR-IPCW-manual-bootstrap","text":"Finally, showcase run bootstrapping procedure manually. allows users parallelise code reduce computational time. done using package boot (Canty Ripley 2022) conjunction calib_msm. start creating permanent object predicted risks individual. validation cohort ebmtcal resampled, appropriate predicted transition probabilities must also resampled object. Next define predicted transition probabilities observed event probabilities plotted, must every bootstrapped calibration curve. predicted transition probabilities individuals uncensored time t, predicted transition probabilities original calibration curves. calibration curves (confidence interval) now calculated. utilise calc_weights function calibmsm estimate weights, function used internally. However, practice point exercise create better performing model estimate weights one internal procedure. vector weights entry every row validation dataset. individuals included landmark cohort, censored prior time tt, weights can take value included calibration model fitted. observed event probabilities can estimated using calib_msm call weights argument. now time estimate confidence interval curve. define function calc_obs_boot generate bootstrapped calibration curve compatible boot function boot (Canty Ripley 2022) package. Within bootstrapped dataset, weights calculated calibration curve estimated using calib_msm. use argument tp.pred.plot essential , ensure bootstrapped observed event probabilities generated vectors predicted transition probabilities. function also written estimate curve transition probabilities specific state kk, output boot must vector, rather matrix. done utilising transitions.argument calib_msm. size confidence interval, states kk individuals may transition state jj, list store data plots defined: bootstrap procedure now applied validation dataset ebmtcal state kk valid_transitions, upper lower confidence bands stored data.frame along calibration curve calculated earlier. Finally, metadata added appropriate class defined data format output calib_msm, meaning can used S3 generic plot. Note example assessed.transitions = valid_transitions, may case estimated calibration curves subset possible transitions. calibration curves manually estimated confidence intervals plotted Figure 3. Figure similar Figures 1 2. expected given used model estimate weights used internal procedure, verifies manual procedure calculating confidence interval successful. Code examples can re-utilised, required specify function estimate inverse probability censoring weights.","code":"tp_pred <- tps0 |>   dplyr::filter(j == 1) |>   dplyr::select(any_of(paste(\"pstate\", 1:6, sep = \"\"))) ## Extract ids for individuals uncensored at t ids_uncens <- ebmtcal |>   subset(dtcens > t | (dtcens < t & dtcens_s == 0)) |>   dplyr::pull(id) ## Extract the predicted risks out of state 1 for these individuals tp_pred_plot <- tps0 |>   dplyr::filter(j == 1 & id %in% ids_uncens) |>   dplyr::select(any_of(paste(\"pstate\", 1:6, sep = \"\"))) weights_manual <-   calc_weights(data_ms = msebmtcal,                data_raw = ebmtcal,                covs = c(\"year\", \"agecl\", \"proph\", \"match\"),                t = t,                s = 0,                landmark_type = \"state\",                j = 1,                max_weight = 10,                stabilised = FALSE)$ipcw str(weights_manual) #>  num [1:2279] NA 1.14 NA 1.01 1.03 ... dat_calib_boot_manual <-   calib_msm(data_ms = msebmtcal,            data_raw = ebmtcal,            j = 1,            s = 0,            t = t,            tp_pred = tp_pred,            calib_type = 'blr',            curve_type = \"rcs\",            rcs_nk = 3,            weights = weights_manual) calc_obs_boot <- function(data, indices, tp_pred, state_k){      ## Bootstrap dataset and predicted transition probabilities   data_boot <- data[indices,]   tp_pred_boot <- tp_pred[indices, ]      ## Calculate weights   ## In practice - replace this function with your own   weights_manual <-     calc_weights(data_ms = msebmtcal[msebmtcal$id %in% data_boot$id, ],                  data_raw = data_boot,                  covs = c(\"year\", \"agecl\", \"proph\", \"match\"),                  t = t,                  s = 0,                  landmark_type = \"state\",                  j = 1,                  max_weight = 10,                  stabilised = FALSE)$ipcw      ## Estimate bootstrapped calibration curve   curve_est <-     calib_msm(data_ms = msebmtcal[msebmtcal$id %in% data_boot$id, ],              data_raw = data_boot,              j=1,              s=0,              t = t,              tp_pred = tp_pred_boot,              calib_type = 'blr',              curve_type = \"rcs\",              rcs_nk = 3,              weights = weights_manual,              tp_pred_plot = tp_pred_plot,              transitions_out = state_k)      ## Extract observed event probabilities   curve_obs <-     curve_est[[\"plotdata\"]][[paste(\"state\", state_k, sep = \"\")]]$obs      return(curve_obs)    } alpha <- (1-95/100)/2 valid_transitions <- which(colSums(tp_pred) != 0) plot_data_list <- vector(\"list\", length(valid_transitions)) for (k in 1:length(valid_transitions)){      ## Assign state k   state_k <- valid_transitions[k]      ## Run bootstrapping   boot_obs <- boot::boot(ebmtcal,                          calc_obs_boot,                          R = 200,                          tp_pred = tp_pred,                          state_k = state_k)$t      ## Extract confidence bands   lower <- apply(boot_obs, 2, stats::quantile, probs = alpha, na.rm = TRUE)   upper <- apply(boot_obs, 2, stats::quantile, probs = 1-alpha, na.rm = TRUE)      ## Assign output   plot_data_list[[k]] <- data.frame(     \"pred\" = dat_calib_boot_manual[[\"plotdata\"]][[k]]$pred,     \"obs\" = dat_calib_boot_manual[[\"plotdata\"]][[k]]$obs,     \"obs_lower\" = lower,     \"obs_upper\" = upper)    } metadata <- list(\"valid_transitions\"= valid_transitions,                  \"assessed_transitions\" = valid_transitions,                  \"CI\" = 95,                  \"curve_type\" = \"rcs\") dat_calib_blr_manual <- list(\"plotdata\" = plot_data_list, \"metadata\" = metadata) attr(dat_calib_blr_manual, \"class\") <- c(\"calib_blr\", \"calib_msm\") plot(dat_calib_blr_manual) #> TableGrob (2 x 1) \"arrange\": 2 grobs #>   z     cells    name              grob #> 1 1 (1-1,1-1) arrange   gtable[arrange] #> 2 2 (2-2,1-1) arrange gtable[guide-box]"},{"path":"https://alexpate30.github.io/calibmsm/articles/Calibration-curves-estimated-with-loess-smoothers.html","id":"data-preperation","dir":"Articles","previous_headings":"","what":"Data preperation","title":"Calibration-curves-estimated-with-loess-smoothers","text":"vignette showcases estimate BLR-IPCW pseudo-value calibration curves using loess smoothers model estimate observed event probabilities. contrast using restricted cubic splines, done Overview vignette. approaches viable refer literature discussion method (Austin, Harrell, Klaveren 2020; Harrell 2015). mimic exactly analysis Overview vignette, specifying loess smoother rather restricted cubic splines, assess whether conclusions different. primarily showcase utility package. use data European Society Blood Marrow Transplantation (EBMT 2023), contains multistate survival data transplant patients blood cancer. start follow day transplant initial state alive remission. three intermediate events (22: recovery, 33: adverse event, 44: recovery + adverse event), two absorbing states (55: relapse 66: death). data originally made available mstate package (Wreede, Fiocco, Putter 2011). start reminding EBMT (Wreede, Fiocco, Putter 2011; EBMT 2023) validation datasets ebmtcal msebmtcal, predicted transition probabilities state j = 1 made time s = 0 multistate model (tps0). also set time want evaluate transition probabilities t. Please refer Overview vignette detailed description data.","code":"set.seed(101)  library(calibmsm)  data(\"ebmtcal\") head(ebmtcal) #>   id  rec rec.s   ae ae.s recae recae.s  rel rel.s  srv srv.s      year agecl #> 1  1   22     1  995    0   995       0  995     0  995     0 1995-1998 20-40 #> 2  2   29     1   12    1    29       1  422     1  579     1 1995-1998 20-40 #> 3  3 1264     0   27    1  1264       0 1264     0 1264     0 1995-1998 20-40 #> 4  4   50     1   42    1    50       1   84     1  117     1 1995-1998 20-40 #> 5  5   22     1 1133    0  1133       0  114     1 1133     0 1995-1998   >40 #> 6  6   33     1   27    1    33       1 1427     0 1427     0 1995-1998 20-40 #>   proph              match dtcens dtcens_s #> 1    no no gender mismatch    995        1 #> 2    no no gender mismatch    422        0 #> 3    no no gender mismatch   1264        1 #> 4    no    gender mismatch     84        0 #> 5    no    gender mismatch    114        0 #> 6    no no gender mismatch   1427        1  data(\"msebmtcal\") head(msebmtcal) #>   id from to trans Tstart Tstop time status #> 1  1    1  2     1      0    22   22      1 #> 2  1    1  3     2      0    22   22      0 #> 3  1    1  5     3      0    22   22      0 #> 4  1    1  6     4      0    22   22      0 #> 5  1    2  4     5     22   995  973      0 #> 6  1    2  5     6     22   995  973      0  data(\"tps0\") head(tps0) #>   id   pstate1   pstate2    pstate3   pstate4   pstate5   pstate6        se1 #> 1  1 0.1139726 0.2295006 0.08450376 0.2326861 0.1504855 0.1888514 0.01291133 #> 2  2 0.1140189 0.2316569 0.08442692 0.2328398 0.1481977 0.1888598 0.01291552 #> 3  3 0.1136646 0.2317636 0.08274331 0.2325663 0.1504787 0.1887834 0.01289444 #> 4  4 0.1383878 0.1836189 0.07579429 0.2179331 0.1538475 0.2304185 0.01857439 #> 5  5 0.1233226 0.1609740 0.05508100 0.1828176 0.1425950 0.3352099 0.01944967 #> 6  6 0.1136646 0.2317636 0.08462424 0.2305854 0.1505534 0.1888087 0.01289444 #>          se2        se3        se4        se5        se6 j #> 1 0.02369584 0.01257251 0.02323376 0.01648630 0.01601795 1 #> 2 0.02374329 0.01256056 0.02324869 0.01632797 0.01603703 1 #> 3 0.02375770 0.01245752 0.02322375 0.01647890 0.01601525 1 #> 4 0.03004447 0.01462570 0.03018673 0.02124071 0.02416121 1 #> 5 0.03419721 0.01367768 0.03423941 0.02329644 0.03688586 1 #> 6 0.02375770 0.01257276 0.02317348 0.01649531 0.01602438 1  t_eval <- 1826"},{"path":"https://alexpate30.github.io/calibmsm/articles/Calibration-curves-estimated-with-loess-smoothers.html","id":"estimation-of-calibration-curves-out-of-state-j-1-at-time-s-0-using-loess-smoothers","dir":"Articles","previous_headings":"","what":"Estimation of calibration curves out of state j = 1 at time s = 0 using loess smoothers","title":"Calibration-curves-estimated-with-loess-smoothers","text":"now produce calibration curves predicted transition probabilities state j=1j = 1 time s=0s = 0. Given individuals start state 11, need consider transition probabilities states j‚â†1j \\neq 1 s=0s = 0. Calibration assessed follow time (t=1826t = 1826 days). start extracting predicted transition probabilities state j=1j = 1 time s=0s = 0 object . transition probabilities aim assess calibration . now produce calibration curves using loess smoothers regression model observed event probabilities estimated. specified . Behaviour curve can controlled using , leave default example. Please refere documentation function package details parameters. smaller span /degree create smoother line. done BLR-IPCW pseudo-value calibration curves. now produce calibration plots using function. equivalent Figures Overview vignette, produced using restricted cubic splines, Figures 2 3. Write short comparison‚Ä¶ XXXX","code":"tp_pred_s0 <- tps0 |>   dplyr::filter(j == 1) |>   dplyr::select(any_of(paste(\"pstate\", 1:6, sep = \"\"))) dat_calib_blr <-   calib_msm(data_ms = msebmtcal,            data_raw = ebmtcal,            j = 1,            s = 0,            t = t_eval,            tp_pred = tp_pred_s0,            calib_type = 'blr',            curve_type = \"loess\",            w_covs = c(\"year\", \"agecl\", \"proph\", \"match\"),            CI = 95,            CI_type = \"bootstrap\",            CI_R_boot = 200) #> Warning in calib_blr_ipcw(data_raw = data_raw, data_ms = data_ms, tp_pred_plot = tp_pred_plot, : WARNING, SOME BOOTSTRAPPED OBSERVED EVENT PROBABILITIES WERE NA FOR STATE 1  #>  THERE ARE  85  ITERATIONS WITH NA's  #>  THE MEAN NUMBER OF NA's IN EACH ITERATION IS 0.835 #> Warning in calib_blr_ipcw(data_raw = data_raw, data_ms = data_ms, tp_pred_plot = tp_pred_plot, : WARNING, SOME BOOTSTRAPPED OBSERVED EVENT PROBABILITIES WERE NA FOR STATE 2  #>  THERE ARE  125  ITERATIONS WITH NA's  #>  THE MEAN NUMBER OF NA's IN EACH ITERATION IS 1.205 #> Warning in calib_blr_ipcw(data_raw = data_raw, data_ms = data_ms, tp_pred_plot = tp_pred_plot, : WARNING, SOME BOOTSTRAPPED OBSERVED EVENT PROBABILITIES WERE NA FOR STATE 3  #>  THERE ARE  133  ITERATIONS WITH NA's  #>  THE MEAN NUMBER OF NA's IN EACH ITERATION IS 1.29 #> Warning in calib_blr_ipcw(data_raw = data_raw, data_ms = data_ms, tp_pred_plot = tp_pred_plot, : WARNING, SOME BOOTSTRAPPED OBSERVED EVENT PROBABILITIES WERE NA FOR STATE 4  #>  THERE ARE  115  ITERATIONS WITH NA's  #>  THE MEAN NUMBER OF NA's IN EACH ITERATION IS 1.025 #> Warning in calib_blr_ipcw(data_raw = data_raw, data_ms = data_ms, tp_pred_plot = tp_pred_plot, : WARNING, SOME BOOTSTRAPPED OBSERVED EVENT PROBABILITIES WERE NA FOR STATE 5  #>  THERE ARE  117  ITERATIONS WITH NA's  #>  THE MEAN NUMBER OF NA's IN EACH ITERATION IS 1.16 #> Warning in calib_blr_ipcw(data_raw = data_raw, data_ms = data_ms, tp_pred_plot = tp_pred_plot, : WARNING, SOME BOOTSTRAPPED OBSERVED EVENT PROBABILITIES WERE NA FOR STATE 6  #>  THERE ARE  111  ITERATIONS WITH NA's  #>  THE MEAN NUMBER OF NA's IN EACH ITERATION IS 1.115  dat_calib_pv <-   calib_msm(data_ms = msebmtcal,            data_raw = ebmtcal,            j = 1,            s = 0,            t = t_eval,            tp_pred = tp_pred_s0,            calib_type = 'pv',            curve_type = \"loess\",            pv_group_vars = c(\"year\"),            pv_n_pctls = 3,            CI = 95,            CI_type = 'parametric') plot(dat_calib_blr) #> TableGrob (2 x 1) \"arrange\": 2 grobs #>   z     cells    name              grob #> 1 1 (1-1,1-1) arrange   gtable[arrange] #> 2 2 (2-2,1-1) arrange gtable[guide-box] plot(dat_calib_pv) #> TableGrob (2 x 1) \"arrange\": 2 grobs #>   z     cells    name              grob #> 1 1 (1-1,1-1) arrange   gtable[arrange] #> 2 2 (2-2,1-1) arrange gtable[guide-box]"},{"path":"https://alexpate30.github.io/calibmsm/articles/Calibration-curves-estimated-with-loess-smoothers.html","id":"estimation-of-calibration-curves-out-of-state-j-1-at-time-s-100-using-loess-smoothers","dir":"Articles","previous_headings":"","what":"Estimation of calibration curves out of state j = 1 at time s = 100 using loess smoothers","title":"Calibration-curves-estimated-with-loess-smoothers","text":"now produce calibration curves predicted transition probabilities state j=1j = 1 time s=100s = 100. Calibration assessed follow time (t=1826t = 1826 days). start extracting predicted transition probabilities state j=1j = 1 time s=100s = 100 object . transition probabilities aim assess calibration . now produce calibration curves using loess smoothers regression model observed event probabilities estimated. specified . Behaviour curve can controlled using , leave default example. Please refere documentation function package details parameters. smaller span /degree create smoother line. done BLR-IPCW pseudo-value calibration curves. now produce calibration plots using function. equivalent Figures Overview vignette, produced using restricted cubic splines, Figures 5 6. Write short comparison‚Ä¶","code":"tp_pred_s100 <- tps100 |>   dplyr::filter(j == 1) |>   dplyr::select(any_of(paste(\"pstate\", 1:6, sep = \"\"))) dat_calib_blr <-   calib_msm(data_ms = msebmtcal,            data_raw = ebmtcal,            j = 1,            s = 100,            t = t_eval,            tp_pred = tp_pred_s100,            calib_type = 'blr',            curve_type = \"loess\",            w_covs = c(\"year\", \"agecl\", \"proph\", \"match\"),            CI = 95,            CI_type = \"bootstrap\",            CI_R_boot = 200) #> Warning in calib_msm(data_ms = msebmtcal, data_raw = ebmtcal, j = 1, s = 100, : In the landmark cohort of individuals uncensored and in state j at time s, #>     there are some states have less than 50 people at the time at which calibration is being assessed (t). #>     Warnings and errors may occur when the models are fitted to estimate the calibration curves due to small sample size. #>     This warning has been written to try and intercept some uninformative error messages when the underlying statistical models fail. #>     The number to flag this warning (50) has been chosen arbitrarily, and does not constitute a sufficient sample size from a statistical point of view. #> Warning in calib_blr_ipcw(data_raw = data_raw, data_ms = data_ms, tp_pred_plot = tp_pred_plot, : WARNING, SOME BOOTSTRAPPED OBSERVED EVENT PROBABILITIES WERE NA FOR STATE 1  #>  THERE ARE  124  ITERATIONS WITH NA's  #>  THE MEAN NUMBER OF NA's IN EACH ITERATION IS 1.105 #> Warning in calib_blr_ipcw(data_raw = data_raw, data_ms = data_ms, tp_pred_plot = tp_pred_plot, : WARNING, SOME BOOTSTRAPPED OBSERVED EVENT PROBABILITIES WERE NA FOR STATE 2  #>  THERE ARE  120  ITERATIONS WITH NA's  #>  THE MEAN NUMBER OF NA's IN EACH ITERATION IS 1.205 #> Warning in calib_blr_ipcw(data_raw = data_raw, data_ms = data_ms, tp_pred_plot = tp_pred_plot, : WARNING, SOME BOOTSTRAPPED OBSERVED EVENT PROBABILITIES WERE NA FOR STATE 5  #>  THERE ARE  99  ITERATIONS WITH NA's  #>  THE MEAN NUMBER OF NA's IN EACH ITERATION IS 0.955 #> Warning in calib_blr_ipcw(data_raw = data_raw, data_ms = data_ms, tp_pred_plot = tp_pred_plot, : WARNING, SOME BOOTSTRAPPED OBSERVED EVENT PROBABILITIES WERE NA FOR STATE 6  #>  THERE ARE  140  ITERATIONS WITH NA's  #>  THE MEAN NUMBER OF NA's IN EACH ITERATION IS 1.375  dat_calib_pv <-   calib_msm(data_ms = msebmtcal,            data_raw = ebmtcal,            j = 1,            s = 100,            t = t_eval,            tp_pred = tp_pred_s100,            calib_type = 'pv',            curve_type = \"loess\",            pv_group_vars = c(\"year\"),            CI = 95,            CI_type = 'parametric') #> Warning in calib_msm(data_ms = msebmtcal, data_raw = ebmtcal, j = 1, s = 100, : In the landmark cohort of individuals uncensored and in state j at time s, #>     there are some states have less than 50 people at the time at which calibration is being assessed (t). #>     Warnings and errors may occur when the models are fitted to estimate the calibration curves due to small sample size. #>     This warning has been written to try and intercept some uninformative error messages when the underlying statistical models fail. #>     The number to flag this warning (50) has been chosen arbitrarily, and does not constitute a sufficient sample size from a statistical point of view. plot(dat_calib_blr) #> TableGrob (2 x 1) \"arrange\": 2 grobs #>   z     cells    name              grob #> 1 1 (1-1,1-1) arrange   gtable[arrange] #> 2 2 (2-2,1-1) arrange gtable[guide-box] plot(dat_calib_pv) #> TableGrob (2 x 1) \"arrange\": 2 grobs #>   z     cells    name              grob #> 1 1 (1-1,1-1) arrange   gtable[arrange] #> 2 2 (2-2,1-1) arrange gtable[guide-box]"},{"path":"https://alexpate30.github.io/calibmsm/articles/Calibration-curves-estimated-with-loess-smoothers.html","id":"estimation-of-calibration-curves-out-of-state-j-3-at-time-s-100-using-loess-smoothers","dir":"Articles","previous_headings":"","what":"Estimation of calibration curves out of state j = 3 at time s = 100 using loess smoothers","title":"Calibration-curves-estimated-with-loess-smoothers","text":"now produce calibration curves predicted transition probabilities state j=3j = 3 time s=100s = 100. Calibration assessed follow time (t=1826t = 1826 days). start extracting predicted transition probabilities state j=3j = 3 time s=100s = 100 object . transition probabilities aim assess calibration . now produce calibration curves using loess smoothers regression model observed event probabilities estimated. specified . Behaviour curve can controlled using , leave default example. Please refere documentation function package details parameters. smaller span /degree create smoother line. done BLR-IPCW pseudo-value calibration curves. now produce calibration plots using function. equivalent Figures Overview vignette, produced using restricted cubic splines, Figures 7 8. Write short comparison‚Ä¶ XXXX","code":"tp_pred_s100 <- tps100 |>   dplyr::filter(j == 3) |>   dplyr::select(any_of(paste(\"pstate\", 1:6, sep = \"\"))) dat_calib_blr <-   calib_msm(data_ms = msebmtcal,            data_raw = ebmtcal,            j = 3,            s = 100,            t = t_eval,            tp_pred = tp_pred_s100,            calib_type = 'blr',            curve_type = \"loess\",            w_covs = c(\"year\", \"agecl\", \"proph\", \"match\"),            CI = 95,            CI_type = \"bootstrap\",            CI_R_boot = 200) #> Warning in calib_msm(data_ms = msebmtcal, data_raw = ebmtcal, j = 3, s = 100, : In the landmark cohort of individuals uncensored and in state j at time s, #>     there are some states have less than 50 people at the time at which calibration is being assessed (t). #>     Warnings and errors may occur when the models are fitted to estimate the calibration curves due to small sample size. #>     This warning has been written to try and intercept some uninformative error messages when the underlying statistical models fail. #>     The number to flag this warning (50) has been chosen arbitrarily, and does not constitute a sufficient sample size from a statistical point of view. #> Warning in calib_blr_ipcw(data_raw = data_raw, data_ms = data_ms, tp_pred_plot = tp_pred_plot, : WARNING, SOME BOOTSTRAPPED OBSERVED EVENT PROBABILITIES WERE NA FOR STATE 3  #>  THERE ARE  124  ITERATIONS WITH NA's  #>  THE MEAN NUMBER OF NA's IN EACH ITERATION IS 1.165 #> Warning in calib_blr_ipcw(data_raw = data_raw, data_ms = data_ms, tp_pred_plot = tp_pred_plot, : WARNING, SOME BOOTSTRAPPED OBSERVED EVENT PROBABILITIES WERE NA FOR STATE 4  #>  THERE ARE  116  ITERATIONS WITH NA's  #>  THE MEAN NUMBER OF NA's IN EACH ITERATION IS 1.15 #> Warning in calib_blr_ipcw(data_raw = data_raw, data_ms = data_ms, tp_pred_plot = tp_pred_plot, : WARNING, SOME BOOTSTRAPPED OBSERVED EVENT PROBABILITIES WERE NA FOR STATE 5  #>  THERE ARE  121  ITERATIONS WITH NA's  #>  THE MEAN NUMBER OF NA's IN EACH ITERATION IS 1.23 #> Warning in calib_blr_ipcw(data_raw = data_raw, data_ms = data_ms, tp_pred_plot = tp_pred_plot, : WARNING, SOME BOOTSTRAPPED OBSERVED EVENT PROBABILITIES WERE NA FOR STATE 6  #>  THERE ARE  112  ITERATIONS WITH NA's  #>  THE MEAN NUMBER OF NA's IN EACH ITERATION IS 1.07  dat_calib_pv <-   calib_msm(data_ms = msebmtcal,            data_raw = ebmtcal,            j = 3,            s = 100,            t = t_eval,            tp_pred = tp_pred_s100,            calib_type = 'pv',            curve_type = \"loess\",            pv_group_vars = c(\"year\"),            CI = 95,            CI_type = 'parametric') #> Warning in calib_msm(data_ms = msebmtcal, data_raw = ebmtcal, j = 3, s = 100, : In the landmark cohort of individuals uncensored and in state j at time s, #>     there are some states have less than 50 people at the time at which calibration is being assessed (t). #>     Warnings and errors may occur when the models are fitted to estimate the calibration curves due to small sample size. #>     This warning has been written to try and intercept some uninformative error messages when the underlying statistical models fail. #>     The number to flag this warning (50) has been chosen arbitrarily, and does not constitute a sufficient sample size from a statistical point of view. plot(dat_calib_blr) #> TableGrob (2 x 1) \"arrange\": 2 grobs #>   z     cells    name              grob #> 1 1 (1-1,1-1) arrange   gtable[arrange] #> 2 2 (2-2,1-1) arrange gtable[guide-box] plot(dat_calib_pv) #> TableGrob (2 x 1) \"arrange\": 2 grobs #>   z     cells    name              grob #> 1 1 (1-1,1-1) arrange   gtable[arrange] #> 2 2 (2-2,1-1) arrange gtable[guide-box]"},{"path":"https://alexpate30.github.io/calibmsm/articles/Calibration-curves-estimated-with-loess-smoothers.html","id":"a-note-on-the-fact-that-confidence-intervals-may-be-lower-than-0-or-bigger-than-1","dir":"Articles","previous_headings":"","what":"A note on the fact that confidence intervals may be lower than 0 or bigger than 1","title":"Calibration-curves-estimated-with-loess-smoothers","text":"Given standard error calculated probability scale , opposed logit scale, confidence intervals may exceed 0 1. checked confidence intervals calculated way CalibrationCurves package: https://cran.r-project.org/web/packages/CalibrationCurves/CalibrationCurves.pdf . particular see code val.prob.ci.2: https://github.com/BavoDC/CalibrationCurves/blob/master/R/val.prob.ci.2.R . parametric confidence intervals calculated way calculate parametric confidence intervals pseudo value approach. therefore confident correct, something ‚Äôd like come back consider implications . ‚Äôs also intriguing even bootstrapped BLR-IPCW confidence intervals, seeing confidence intervals well outside 0 1. thought issue pseudo-value parametric confidence intervals just adding 1.96*se probability scale. However, didnt actually think possible bootstrapped confidence intervals, given bootstrapped dataset, predicted-observed values still lie 0 1, something explore detail. done bit research (see test_loess_bootstrap.R test folder), values 0 driven small number individuals smallest risks. Lots predicted-observed values NAs, negative values . evident small number individuals driving NA values finding bootstrap iteration. Going try increasing span see helps. Now know mechanism, although something ‚Äôm particularly worried , seems driven small sample size assessing calibration time s = 100. Compare following graphs figures 1 2 . First . now produce calibration plots using function. . now produce calibration plots using function.","code":"dat_calib_blr <-   calib_msm(data_ms = msebmtcal,            data_raw = ebmtcal,            j = 1,            s = 0,            t = t_eval,            tp_pred = tp_pred_s0,            calib_type = 'blr',            curve_type = \"loess\",            loess_span = 0.9,            w_covs = c(\"year\", \"agecl\", \"proph\", \"match\"),            CI = 95,            CI_type = \"bootstrap\",            CI_R_boot = 200) #> Warning in calib_blr_ipcw(data_raw = data_raw, data_ms = data_ms, tp_pred_plot = tp_pred_plot, : WARNING, SOME BOOTSTRAPPED OBSERVED EVENT PROBABILITIES WERE NA FOR STATE 1  #>  THERE ARE  94  ITERATIONS WITH NA's  #>  THE MEAN NUMBER OF NA's IN EACH ITERATION IS 0.91 #> Warning in calib_blr_ipcw(data_raw = data_raw, data_ms = data_ms, tp_pred_plot = tp_pred_plot, : WARNING, SOME BOOTSTRAPPED OBSERVED EVENT PROBABILITIES WERE NA FOR STATE 2  #>  THERE ARE  118  ITERATIONS WITH NA's  #>  THE MEAN NUMBER OF NA's IN EACH ITERATION IS 1.16 #> Warning in calib_blr_ipcw(data_raw = data_raw, data_ms = data_ms, tp_pred_plot = tp_pred_plot, : WARNING, SOME BOOTSTRAPPED OBSERVED EVENT PROBABILITIES WERE NA FOR STATE 3  #>  THERE ARE  116  ITERATIONS WITH NA's  #>  THE MEAN NUMBER OF NA's IN EACH ITERATION IS 0.95 #> Warning in calib_blr_ipcw(data_raw = data_raw, data_ms = data_ms, tp_pred_plot = tp_pred_plot, : WARNING, SOME BOOTSTRAPPED OBSERVED EVENT PROBABILITIES WERE NA FOR STATE 4  #>  THERE ARE  119  ITERATIONS WITH NA's  #>  THE MEAN NUMBER OF NA's IN EACH ITERATION IS 1.135 #> Warning in calib_blr_ipcw(data_raw = data_raw, data_ms = data_ms, tp_pred_plot = tp_pred_plot, : WARNING, SOME BOOTSTRAPPED OBSERVED EVENT PROBABILITIES WERE NA FOR STATE 5  #>  THERE ARE  131  ITERATIONS WITH NA's  #>  THE MEAN NUMBER OF NA's IN EACH ITERATION IS 1.315 #> Warning in calib_blr_ipcw(data_raw = data_raw, data_ms = data_ms, tp_pred_plot = tp_pred_plot, : WARNING, SOME BOOTSTRAPPED OBSERVED EVENT PROBABILITIES WERE NA FOR STATE 6  #>  THERE ARE  115  ITERATIONS WITH NA's  #>  THE MEAN NUMBER OF NA's IN EACH ITERATION IS 1.145  dat_calib_pv <-   calib_msm(data_ms = msebmtcal,            data_raw = ebmtcal,            j = 1,            s = 0,            t = t_eval,            tp_pred = tp_pred_s0,            calib_type = 'pv',            curve_type = \"loess\",            loess_span = 0.9,            pv_group_vars = c(\"year\"),            pv_n_pctls = 3,            CI = 95,            CI_type = 'parametric') plot(dat_calib_blr) #> TableGrob (2 x 1) \"arrange\": 2 grobs #>   z     cells    name              grob #> 1 1 (1-1,1-1) arrange   gtable[arrange] #> 2 2 (2-2,1-1) arrange gtable[guide-box] plot(dat_calib_pv) #> TableGrob (2 x 1) \"arrange\": 2 grobs #>   z     cells    name              grob #> 1 1 (1-1,1-1) arrange   gtable[arrange] #> 2 2 (2-2,1-1) arrange gtable[guide-box] dat_calib_blr <-   calib_msm(data_ms = msebmtcal,            data_raw = ebmtcal,            j = 1,            s = 0,            t = t_eval,            tp_pred = tp_pred_s0,            calib_type = 'blr',            curve_type = \"loess\",            loess_span = 1,            w_covs = c(\"year\", \"agecl\", \"proph\", \"match\"),            CI = 95,            CI_type = \"bootstrap\",            CI_R_boot = 200) #> Warning in calib_blr_ipcw(data_raw = data_raw, data_ms = data_ms, tp_pred_plot = tp_pred_plot, : WARNING, SOME BOOTSTRAPPED OBSERVED EVENT PROBABILITIES WERE NA FOR STATE 1  #>  THERE ARE  86  ITERATIONS WITH NA's  #>  THE MEAN NUMBER OF NA's IN EACH ITERATION IS 0.805 #> Warning in calib_blr_ipcw(data_raw = data_raw, data_ms = data_ms, tp_pred_plot = tp_pred_plot, : WARNING, SOME BOOTSTRAPPED OBSERVED EVENT PROBABILITIES WERE NA FOR STATE 2  #>  THERE ARE  130  ITERATIONS WITH NA's  #>  THE MEAN NUMBER OF NA's IN EACH ITERATION IS 1.27 #> Warning in calib_blr_ipcw(data_raw = data_raw, data_ms = data_ms, tp_pred_plot = tp_pred_plot, : WARNING, SOME BOOTSTRAPPED OBSERVED EVENT PROBABILITIES WERE NA FOR STATE 3  #>  THERE ARE  128  ITERATIONS WITH NA's  #>  THE MEAN NUMBER OF NA's IN EACH ITERATION IS 1.255 #> Warning in calib_blr_ipcw(data_raw = data_raw, data_ms = data_ms, tp_pred_plot = tp_pred_plot, : WARNING, SOME BOOTSTRAPPED OBSERVED EVENT PROBABILITIES WERE NA FOR STATE 4  #>  THERE ARE  123  ITERATIONS WITH NA's  #>  THE MEAN NUMBER OF NA's IN EACH ITERATION IS 1.125 #> Warning in calib_blr_ipcw(data_raw = data_raw, data_ms = data_ms, tp_pred_plot = tp_pred_plot, : WARNING, SOME BOOTSTRAPPED OBSERVED EVENT PROBABILITIES WERE NA FOR STATE 5  #>  THERE ARE  132  ITERATIONS WITH NA's  #>  THE MEAN NUMBER OF NA's IN EACH ITERATION IS 1.285 #> Warning in calib_blr_ipcw(data_raw = data_raw, data_ms = data_ms, tp_pred_plot = tp_pred_plot, : WARNING, SOME BOOTSTRAPPED OBSERVED EVENT PROBABILITIES WERE NA FOR STATE 6  #>  THERE ARE  112  ITERATIONS WITH NA's  #>  THE MEAN NUMBER OF NA's IN EACH ITERATION IS 1.02  dat_calib_pv <-   calib_msm(data_ms = msebmtcal,            data_raw = ebmtcal,            j = 1,            s = 0,            t = t_eval,            tp_pred = tp_pred_s0,            calib_type = 'pv',            curve_type = \"loess\",            loess_span = 1,            pv_group_vars = c(\"year\"),            pv_n_pctls = 3,            CI = 95,            CI_type = 'parametric') plot(dat_calib_blr) #> TableGrob (2 x 1) \"arrange\": 2 grobs #>   z     cells    name              grob #> 1 1 (1-1,1-1) arrange   gtable[arrange] #> 2 2 (2-2,1-1) arrange gtable[guide-box] plot(dat_calib_pv) #> TableGrob (2 x 1) \"arrange\": 2 grobs #>   z     cells    name              grob #> 1 1 (1-1,1-1) arrange   gtable[arrange] #> 2 2 (2-2,1-1) arrange gtable[guide-box]"},{"path":"https://alexpate30.github.io/calibmsm/articles/Comparison-in-competing-risks-setting.html","id":"data-preperation","dir":"Articles","previous_headings":"","what":"Data preperation","title":"Comparison-in-competing-risks-setting","text":"vignette compares calibration competing risks model assessed using approaches provided calibmsm, namely BLR-IPCW pseudo-value approaches, graphical calibration curves developed Austin et al. (2022). use data European Society Blood Marrow Transplantation (EBMT 2023), contains multistate survival data transplant patients blood cancer. start follow day transplant initial state alive remission. three intermediate events (22: recovery, 33: adverse event, 44: recovery + adverse event), two absorbing states (55: relapse 66: death). data originally made available mstate package (Wreede, Fiocco, Putter 2011). example, treat transitions first state standalone competing risks model setting subsequent states absorbing states. ignoring subsequent multistate aspect data. first load predicted transition probabilities individual model, provided dataset tp_cmprsk_j0. code deriving available source code package (see prepare_vignette_cmprsk_data.R). generated specifying transition matrix define competing risks model (.e.¬†subsequent states act absorbing states), generate predicted risks (cumulative incidence functions) using theory Putter, Fiocco, Geskus (2007). derived using software mstate (Wreede, Fiocco, Putter 2011). Predicted risks generated individual using leave-one-approach (.e.¬†individual removed dataset fitting competing risks model estimating predicted risk individual). following four variables used estimate predicted risks: year transplant (year), age transplant (age), prophylaxis given (proph), whether donor gender matched (match). transition probabilities stored object tp_cmprsk_j0. Datasets formats required function calib_msm stored ebmtcal.cmprsk (data_raw argument) msebmtcal_cmprsk (data_ms argument). Note ebmtcal.cmprsk ebmtcal except variables dtcens dtcens.s derived different manner. Specifically, setting entry state effect preventing censoring absorbing states, whereas ebmtcal true entry states 5 6, however difference two datasets, completely new dataset data.ms argument required, reflects fact now competing risks data structure. Please refer Overview vignette details datasets formatted, refer source code specifically two datasets derived. assess calibration 5 years (1826 days) methods.","code":"library(calibmsm)  data(\"tp_cmprsk_j0\") head(tp_cmprsk_j0) #>   id   pstate1   pstate2   pstate3 pstate4    pstate5    pstate6        se1 #> 1  1 0.1135057 0.4093590 0.3964498       0 0.02688596 0.05379955 0.01291270 #> 2  2 0.1135518 0.4114981 0.3942408       0 0.02689840 0.05381085 0.01291690 #> 3  3 0.1131989 0.4117482 0.3944988       0 0.02681945 0.05373457 0.01289565 #> 4  4 0.1376981 0.3870386 0.3728509       0 0.04027730 0.06213511 0.01858789 #> 5  5 0.1227877 0.4277392 0.3496972       0 0.03130458 0.06847131 0.01945048 #> 6  6 0.1131989 0.4117482 0.3944988       0 0.02681945 0.05373457 0.01289565 #>          se2        se3 se4         se5         se6 #> 1 0.01918215 0.01874680   0 0.006339773 0.007719292 #> 2 0.01920148 0.01870398   0 0.006342388 0.007719937 #> 3 0.01921355 0.01871733   0 0.006325238 0.007708340 #> 4 0.02447306 0.02323096   0 0.010698591 0.010818696 #> 5 0.02777129 0.02476595   0 0.009947925 0.012554747 #> 6 0.01921355 0.01871733   0 0.006325238 0.007708340  data(\"ebmtcal_cmprsk\") head(ebmtcal_cmprsk) #>   id  rec rec.s   ae ae.s recae recae.s  rel rel.s  srv srv.s      year agecl #> 1  1   22     1  995    0   995       0  995     0  995     0 1995-1998 20-40 #> 2  2   29     1   12    1    29       1  422     1  579     1 1995-1998 20-40 #> 3  3 1264     0   27    1  1264       0 1264     0 1264     0 1995-1998 20-40 #> 4  4   50     1   42    1    50       1   84     1  117     1 1995-1998 20-40 #> 5  5   22     1 1133    0  1133       0  114     1 1133     0 1995-1998   >40 #> 6  6   33     1   27    1    33       1 1427     0 1427     0 1995-1998 20-40 #>   proph              match dtcens dtcens_s #> 1    no no gender mismatch     22        0 #> 2    no no gender mismatch     12        0 #> 3    no no gender mismatch     27        0 #> 4    no    gender mismatch     42        0 #> 5    no    gender mismatch     22        0 #> 6    no no gender mismatch     27        0  data(\"msebmtcal_cmprsk\") head(msebmtcal_cmprsk) #>   id from to trans Tstart Tstop time status #> 1  1    1  2     1      0    22   22      1 #> 2  1    1  3     2      0    22   22      0 #> 3  1    1  5     3      0    22   22      0 #> 4  1    1  6     4      0    22   22      0 #> 5  2    1  2     1      0    12   12      0 #> 6  2    1  3     2      0    12   12      1"},{"path":"https://alexpate30.github.io/calibmsm/articles/Comparison-in-competing-risks-setting.html","id":"assess-calibration-using-blr-ipcw","dir":"Articles","previous_headings":"","what":"Assess calibration using BLR-IPCW","title":"Comparison-in-competing-risks-setting","text":"first assess calibration competing risks model using BLR-IPCW approach.","code":"### Estimate calibration curves dat_calib_blr <-   calib_msm(data_ms = msebmtcal_cmprsk,            data_raw = ebmtcal_cmprsk,            j=1,            s=0,            t = 1826,            tp_pred = tp_cmprsk_j0 |>              dplyr::select(any_of(paste(\"pstate\", 1:6, sep = \"\"))),            calib_type = 'blr',            curve_type = \"rcs\",            rcs_nk = 3,            w_covs = c(\"year\", \"agecl\", \"proph\", \"match\"),            CI = 95,            CI_R_boot = 200)  ### Turn into plot and print plot_calibmsm_blr <- plot(dat_calib_blr, combine = TRUE, nrow = 2, ncol = 3) plot_calibmsm_blr #> TableGrob (2 x 1) \"arrange\": 2 grobs #>   z     cells    name              grob #> 1 1 (1-1,1-1) arrange   gtable[arrange] #> 2 2 (2-2,1-1) arrange gtable[guide-box]"},{"path":"https://alexpate30.github.io/calibmsm/articles/Comparison-in-competing-risks-setting.html","id":"assess-calibration-using-pseudo-values","dir":"Articles","previous_headings":"","what":"Assess calibration using pseudo-values","title":"Comparison-in-competing-risks-setting","text":"Next assess calibration competing risks model using pseudo-value approach, implemented calib_pv.","code":"### Estimate calibration curves dat_calib_pv <-   calib_msm(data_ms = msebmtcal_cmprsk,            data_raw = ebmtcal_cmprsk,            j=1,            s=0,            t = 1826,            tp_pred = tp_cmprsk_j0 |>              dplyr::select(any_of(paste(\"pstate\", 1:6, sep = \"\"))),            calib_type = 'pv',            curve_type = \"rcs\",            rcs_nk = 3,            pv_group_vars = c(\"year\"),            pv_n_pctls = 3,            CI = 95,            CI_type = \"parametric\")  ### Turn into plot and print plot_calibmsm_pv <- plot(dat_calib_pv, combine = TRUE, nrow = 2, ncol = 3) plot_calibmsm_pv #> TableGrob (2 x 1) \"arrange\": 2 grobs #>   z     cells    name              grob #> 1 1 (1-1,1-1) arrange   gtable[arrange] #> 2 2 (2-2,1-1) arrange gtable[guide-box]"},{"path":"https://alexpate30.github.io/calibmsm/articles/Comparison-in-competing-risks-setting.html","id":"assess-calibration-using-graphical-calibration-curves","dir":"Articles","previous_headings":"","what":"Assess calibration using graphical calibration curves","title":"Comparison-in-competing-risks-setting","text":"Finally assess calibration competing risks model using graphical calibration curves approach Austin et al. (2022). custom function written , estimates calibration curves returns list plots using ggplot2. function applied estimate calibration curves create plots. Figure 3: Calibration plots competing risks model starting state using graphical calibration curves","code":"calc_calib_gcc_mod <- function(data_ms, data_raw, j, s, t, p_est, nk = 3){                                            ### Assign colnames to p_est   colnames(p_est) <- paste(\"p_est\", 1:ncol(p_est), sep = \"\")      ### Extract what states an individual can move into from state j (states with a non-zero predicted risk)   ### Also drop the staet that an individual is already in, because there is no cmprsk model for staying in the same state   valid_transitions <- which(colSums(p_est) != 0)   valid_transitions <- valid_transitions[-(valid_transitions == j)]      ### Add the predicted risks, and the complementary log log transormation of the predicted risks to data_raw   p_est_cll <- log(-log(1 - p_est[,valid_transitions]))   colnames(p_est_cll) <- paste(\"p_est_cll\", valid_transitions, sep = \"\")      ### Identify individuals who are in state j at time s   ids_state_j <- base::subset(data_ms, from == j & Tstart <= s & s < Tstop) |>     dplyr::select(id) |>     dplyr::distinct(id) |>     dplyr::pull(id)      ### Subset data_ms and data_raw to these individuals.   data_ms <- data_ms |> base::subset(id %in% ids_state_j)   data_raw <- data_raw |> base::subset(id %in% ids_state_j)      ### Add the cloglog risks and predicted risks to the landmark dataset   data_raw <- cbind(data_raw, p_est[,valid_transitions], p_est_cll)      ### Finally, identify individuals which are censored before experiencing any events (used to maniuplate data for Fine-Gray regression later)   ids_cens  <- data_ms |> base::subset(from == j) |> dplyr::group_by(id) |> dplyr::summarize(sum = sum(status)) |> base::subset(sum == 0) |>     dplyr::pull(id)      ###   ### Produce calibration plots for each possible transition   ###      ### Start by creating a list to store the plots   plots_list <- vector(\"list\", length(valid_transitions))      for (k in 1:length(valid_transitions)){         ### Assign state.k     state_k <- as.numeric(valid_transitions[k])          ### Create restricted cubic splines for the cloglog of the linear predictor for the state of interst     rcs_mat <- Hmisc::rcspline.eval(data_raw[,paste(\"p_est_cll\", state_k, sep = \"\")],nk=nk,inclx=T)     colnames(rcs_mat) <- paste(\"rcs_x\", 1:ncol(rcs_mat), sep = \"\")     knots <- attr(rcs_mat,\"knots\")          ### Create a new dataframe for the validation, to avoid recurison with data_raw     ### Add the cubic splines for thecomplementary loglog of the predicted probability, and the predicted probability itself     valid_df <- data.frame(data_raw$id, data_raw[,paste(\"p_est\", state_k, sep = \"\")], rcs_mat)     colnames(valid_df) <- c(\"id\", \"pred\", colnames(rcs_mat))          ### Want to validate the competing risks model out of state j at time s, into state k, so remove individuals not in state k at time s,     ### and only retain transitions into state k. Also deduct immortal time from time variable     data_ms_j_k_s <- base::subset(data_ms, from == j & to == state_k & Tstart <= s & s < Tstop) |>       dplyr::mutate(time = Tstop - s) |>       dplyr::select(c(time, status))          ### Add to valid_df     valid_df <- cbind(valid_df, data_ms_j_k_s)          ### For individuals who do not have the event of interest, and also are not censored (i.e. they have a different competing event),     ### set the follow up time to the maximum     valid_df <- dplyr::mutate(valid_df, time = dplyr::case_when(status == 0 & !(id %in% ids_cens) ~ max(time),                                                                 TRUE ~ time))          ### Create dataset to fit the recalibration model of Austin et al (Graphical calibration curves, BMC Diagnostic and Prognostic, DOI10.1186/s41512-021-00114-6)     valid_df_crprep <- mstate::crprep(Tstop='time',status='status',trans=1,                                       keep=colnames(rcs_mat),valid_df)          ### Create formula and fit the Fine-Gray recalibration model     eq_LHS <- paste(\"survival::Surv(Tstart,Tstop,status==1)~\")     eq_RHS <- paste(\"rcs_x\", 1:ncol(rcs_mat), sep = \"\", collapse = \"+\")     eq <- formula(paste(eq_LHS, eq_RHS, sep = \"\"))     model_calibrate_fg <- rms::cph(eq,weights=weight.cens,x=T,y=T,surv=T,data=valid_df_crprep)          ### Generate predicted probabilities and standard errors     valid_df$obs_fg <- 1-rms::survest(model_calibrate_fg,newdata=valid_df_crprep,time=t-s)$surv     valid_df$obs_fg_upper<-1-rms::survest(model_calibrate_fg,newdata=valid_df_crprep,time=t-s)$lower     valid_df$obs_fg_lower<-1-rms::survest(model_calibrate_fg,newdata=valid_df_crprep,time=t-s)$upper          ### Produce plots for each and store in a list          ### Pivot longer to create data for ggplot and assign appropriate labels     valid_df_longer <- tidyr::pivot_longer(valid_df, cols = c(obs_fg, obs_fg_upper, obs_fg_lower), names_to = \"line_group\")     valid_df_longer <- dplyr::mutate(valid_df_longer,                                      line_group = factor(line_group),                                      mapping = dplyr::case_when(line_group == \"obs_fg\" ~ 1,                                                                 line_group %in% c(\"obs_fg_upper\", \"obs_fg_lower\") ~ 2),                                      mapping = factor(mapping))          levels(valid_df_longer$line_group) <- c(\"Calibration\", \"Upper\", \"Lower\")     levels(valid_df_longer$mapping) <- c(\"Calibration\", \"95% CI\")          ### Create the plot     plots_list[[k]] <- ggplot2::ggplot(data = valid_df_longer |> dplyr::arrange(pred) |> dplyr::select(id, pred, line_group, value, mapping)) +       ggplot2::geom_line(ggplot2::aes(x = pred, y = value, group = line_group, color = mapping)) +       ggplot2::geom_abline(intercept = 0, slope = 1, linetype = \"dashed\") +       ggplot2::xlab(\"Predicted risk\") + ggplot2::ylab(\"Observed risk\") +       ggplot2::xlim(c(0, max(valid_df_longer$pred,                              valid_df_longer$value))) +       ggplot2::ylim(c(0, max(valid_df_longer$pred,                              valid_df_longer$value))) +       ggplot2::geom_rug(data = valid_df_longer |> dplyr::arrange(pred) |> dplyr::select(id, pred, line_group, value, mapping) |> base::subset(line_group == \"Calibration\"),                         ggplot2::aes(x = pred, y = value), col = grDevices::rgb(1, 0, 0, alpha = .1)) +       ggplot2::theme(legend.position = \"none\") +       ggplot2::ggtitle(paste(\"State \", state_k, sep = \"\"))        }      ### Return plots   return(plots_list) } ### Estimate calibration curves and create plots plot_gcc_rcs_list <- calc_calib_gcc_mod(data_ms = msebmtcal_cmprsk,                                         data_raw = ebmtcal_cmprsk,                                         j = 1,                                         s = 0,                                         t = 1826,                                         p_est = tp_cmprsk_j0[,paste(\"pstate\", 1:6, sep = \"\")],                                         nk = 3)  ### Combine into one plot and print plot_gcc_rcs <- ggpubr::ggarrange(plotlist = plot_gcc_rcs_list) plot_gcc_rcs"},{"path":"https://alexpate30.github.io/calibmsm/articles/Comparison-in-competing-risks-setting.html","id":"comarpsion-of-results","dir":"Articles","previous_headings":"","what":"Comarpsion of results","title":"Comparison-in-competing-risks-setting","text":"calibration transition probabilities similar irrespective method used assess calibration. exception calibration transition probabilities state 3 using BLR-IPCW approach. Possible reasons discussed Evaluation--estimation--IPCWs vignette. practice, worth assessing calibration using variety approaches. agreement found, provide reassurance assessment calibration. Note graphical calibration curves approach provide way assess calibration state 1, hence difference number plots.","code":""},{"path":"https://alexpate30.github.io/calibmsm/articles/Sensitivity-analysis-for-IPCWs.html","id":"introduction","dir":"Articles","previous_headings":"","what":"Introduction","title":"Sensitivity-analyses-for-IPCWs","text":"vignette explores sensitivty BLR-IPCW approach estimation weights. start follow day transplant initial state alive remission. three intermediate events (22: recovery, 33: adverse event, 44: recovery + adverse event), two absorbing states (55: relapse 66: death). data originally made available mstate package (Wreede, Fiocco, Putter 2011). Please refer Overview vignette detailed description data. analysis motivated fact illustrative example Overview vignette, saw considerable difference estimated calibration curves state j=1j = 1 state k=3k = 3 using either BLR-IPCW pseudo-value approach. states show similar level calibration using either method, provides reassurance validity, case state 3, investigation required. One hypothesis difference cox-proportional hazards model used estimate weights implemtning BLR-IPCW approach, ‚Äôs possible proportional hazards assumption hold. therefore explore validity assumption, re-estimate calibration curves using flexible parametric survival model estimate weights.(Royston Parmar 2002)","code":""},{"path":"https://alexpate30.github.io/calibmsm/articles/Sensitivity-analysis-for-IPCWs.html","id":"exploring-the-assumption-of-proportional-hazards-in-the-model-for-estimating-the-ipcws","dir":"Articles","previous_headings":"","what":"Exploring the assumption of proportional hazards in the model for estimating the IPCWs","title":"Sensitivity-analyses-for-IPCWs","text":"key variable predicts censoring mechanism year transplant, year. Individuals transplant recently shorter administrative censoring time, given shorter maximum follow . can view looking distribution maximum follow time individual (time either censoring, entering absorbing state 55 66) stratified year. Load libraries functions: Load data: Look maximum follow :  fitting cox proportional hazards model estimate weights, clearly violate proportional hazards assumption given differential follow group. opted censor individuals 5-years follow (1826 days) fitting model. specified w_max_follow argument calib_msm. can calculate weights running calc_weights function: can view distribution weights:  weights estimated fitting following model: Note still large hazard-ratio year 1995-1998 variable, although expected given shorter follow times. Testing proportional hazards assumption, find hold predictor variables, although year worse variables.  can therefore conclude year variable alone driving poor estimation weights, however, proportional hazards assumption hold. therefore proceed estimate weights using flexible parametric model evaluate whether differences.","code":"set.seed(101)  library(calibmsm) library(ggplot2) library(dplyr) ##  ## Attaching package: 'dplyr' ## The following objects are masked from 'package:stats': ##  ##     filter, lag ## The following objects are masked from 'package:base': ##  ##     intersect, setdiff, setequal, union library(survival) requireNamespace(\"survminer\", quietly = TRUE) library(survminer) ## Loading required package: ggpubr ##  ## Attaching package: 'survminer' ## The following object is masked from 'package:survival': ##  ##     myeloma requireNamespace(\"flexsurv\", quietly = TRUE) library(flexsurv) data(\"ebmtcal\") head(ebmtcal) ##   id  rec rec.s   ae ae.s recae recae.s  rel rel.s  srv srv.s      year agecl ## 1  1   22     1  995    0   995       0  995     0  995     0 1995-1998 20-40 ## 2  2   29     1   12    1    29       1  422     1  579     1 1995-1998 20-40 ## 3  3 1264     0   27    1  1264       0 1264     0 1264     0 1995-1998 20-40 ## 4  4   50     1   42    1    50       1   84     1  117     1 1995-1998 20-40 ## 5  5   22     1 1133    0  1133       0  114     1 1133     0 1995-1998   >40 ## 6  6   33     1   27    1    33       1 1427     0 1427     0 1995-1998 20-40 ##   proph              match dtcens dtcens_s ## 1    no no gender mismatch    995        1 ## 2    no no gender mismatch    422        0 ## 3    no no gender mismatch   1264        1 ## 4    no    gender mismatch     84        0 ## 5    no    gender mismatch    114        0 ## 6    no no gender mismatch   1427        1 data(\"msebmtcal\") head(msebmtcal) ## An object of class 'msdata' ##  ## Data: ##   id from to trans Tstart Tstop time status ## 1  1    1  2     1      0    22   22      1 ## 2  1    1  3     2      0    22   22      0 ## 3  1    1  5     3      0    22   22      0 ## 4  1    1  6     4      0    22   22      0 ## 5  1    2  4     5     22   995  973      0 ## 6  1    2  5     6     22   995  973      0 t_eval <- 1826 ebmtcal |>   ggplot(aes(dtcens)) + geom_histogram() + facet_wrap(~year) ## `stat_bin()` using `bins = 30`. Pick better value with `binwidth`. ebmtcal$ipcw_ph <- calc_weights(data_ms = msebmtcal,                                  data_raw = ebmtcal,                                  covs = c(\"year\", \"agecl\", \"proph\", \"match\"),                                  t = t_eval, s = 0, j = 1,                                  max_follow = t_eval)$ipcw ebmtcal |>   ggplot(aes(ipcw_ph)) + geom_histogram() ## `stat_bin()` using `bins = 30`. Pick better value with `binwidth`. ## Warning: Removed 501 rows containing non-finite outside the scale range ## (`stat_bin()`). ebmtcal_5y <- mutate(ebmtcal,                      dtcens_s = case_when(dtcens > 1826 ~ 0,                                           TRUE ~ dtcens_s),                      dtcens = case_when(dtcens > 1826 ~ 1826,                                         TRUE ~ dtcens))  model_ipcw_ph <- survival::coxph(survival::Surv(dtcens, dtcens_s) ~ year + agecl + proph + match, data = ebmtcal_5y) model_ipcw_ph ## Call: ## survival::coxph(formula = survival::Surv(dtcens, dtcens_s) ~  ##     year + agecl + proph + match, data = ebmtcal_5y) ##  ##                          coef exp(coef) se(coef)      z        p ## year1990-1994         1.23753   3.44710  0.25132  4.924 8.48e-07 ## year1995-1998         3.21074  24.79734  0.23772 13.506  < 2e-16 ## agecl20-40           -0.08229   0.92101  0.11159 -0.737    0.461 ## agecl>40              0.04593   1.04700  0.12506  0.367    0.713 ## prophyes              0.01612   1.01625  0.11901  0.135    0.892 ## matchgender mismatch -0.06660   0.93557  0.10722 -0.621    0.534 ##  ## Likelihood ratio test=617.3  on 6 df, p=< 2.2e-16 ## n= 2279, number of events= 501 phtest <- cox.zph(model_ipcw_ph) survminer::ggcoxzph(phtest, resid = FALSE, se = FALSE)"},{"path":"https://alexpate30.github.io/calibmsm/articles/Sensitivity-analysis-for-IPCWs.html","id":"flexible-parametric-model-for-estimating-the-inverse-probability-of-censoring-weights","dir":"Articles","previous_headings":"","what":"Flexible parametric model for estimating the inverse probability of censoring weights","title":"Sensitivity-analyses-for-IPCWs","text":"start defining function estimate weights using flexibe parametric survival model(Royston Parmar 2002) (implemented R using flexsurv(Jackson 2016)). use function calculate weights: can view distribution weights:  see little difference compared weights estimated using cox-proportional hazards model. Next use function estimate calibration curves. implemented input argument w_function calib_msm. function calc_weights_flexsurv also extra argument (covs_tv) compared default function estimating weights (calc_weights). variable used specify variables modelled time-varying coefficients (time-varying hazard ratio), wherein coefficient modelled spline term (function uses 3 degrees freedom) described Royston Parmar (2002). variable also specified running calib_msm. comparison, plot calibration curves using default internal approach (cox proportional hazards). First estimate calibration curves: Plot calibration curves: BLR-IPCW calibration curves using cox proportional hazards model estimate weights BLR-IPCW calibration curves using flexible parametric model estimate weights little difference, estimated calibration curves sensitive choice model estimate inverse probability censoring weights. difference BLR-IPCW pseudo-calibration curves therefore unlikely driven . therefore turn attention assumption outcome censoring distributions conditionally independent given weights.","code":"calc_weights_flexsurv <- function(data_ms, data_raw, covs = NULL, t, s, landmark_type = \"state\", j = NULL, max_weight = 10, stabilised = FALSE, max_follow = NULL, covs_tv = NULL){    ### Modify everybody to be censored after time t, if a max_follow has been specified   if(!is.null(max_follow)){      ### Stop if max follow is smaller than t     if (max_follow < t){       stop(\"Max follow cannot be smaller than t\")     } else {       data_raw <- dplyr::mutate(data_raw,                                 dtcens_s = dplyr::case_when(dtcens < max_follow + 2 ~ dtcens_s,                                                             dtcens >= max_follow + 2 ~ 0),                                 dtcens = dplyr::case_when(dtcens < max_follow + 2 ~ dtcens,                                                           dtcens >= max_follow + 2 ~ max_follow + 2))     }   }    ### Create a new outcome, which is the time until censored from s   data_raw$dtcens_modified <- data_raw$dtcens - s    ### Save a copy of data_raw   data_raw_save <- data_raw    ### If landmark_type = \"state\", calculate weights only in individuals in state j at time s   ### If landmark_type = \"all\", calculate weights in all uncensored individuals at time s (note that this excludes individuals   ### who have reached absorbing states, who have been 'censored' from the survival distribution is censoring)   if (landmark_type == \"state\"){     ### Identify individuals who are uncensored in state j at time s     ids_uncens <- base::subset(data_ms, from == j & Tstart <= s & s < Tstop) |>       dplyr::select(id) |>       dplyr::distinct(id) |>       dplyr::pull(id)    } else if (landmark_type == \"all\"){     ### Identify individuals who are uncensored time s     ids_uncens <- base::subset(data_ms, Tstart <= s & s < Tstop) |>       dplyr::select(id) |>       dplyr::distinct(id) |>       dplyr::pull(id)    }    ### Subset data_ms and data_raw to these individuals   data_ms <- data_ms |> base::subset(id %in% ids_uncens)   data_raw <- data_raw |> base::subset(id %in% ids_uncens)    ### Assign degree of freedom for baseline hazard   baseline_df <- 3      ### Create formula for flexible parametric model   form <- as.formula(paste(\"survival::Surv(\",                            \"dtcens_modified\",                            \",\",                            \"dtcens_s\",                            \") ~\",                            paste(unlist(covs), collapse = \"+\")))   if(is.null(covs_tv)) {     cens_model <- flexsurv::flexsurvspline(       formula = form,       data = data_raw,       k = baseline_df,       scale = \"hazard\"     )   } else {      covs_tv_list <- vector(\"list\", length = baseline_df+1)     names(covs_tv_list) <- paste(\"gamma\", 1:(baseline_df+1), sep = \"\")     covs_tv_list[paste(\"gamma\",                    1:(baseline_df+1),                    sep = \"\")] <- paste(\"~\",                                        paste(unlist(covs_tv),                                              collapse = \"+\"))      cens_model <- flexsurv::flexsurvspline(       formula = form,       anc = lapply(covs_tv_list, as.formula),       data = data_raw,       k = baseline_df,       scale = \"hazard\"     )   }    ### Identify individuals who entered absorbing states or were censored prior to evaluation time   obs_absorbed_prior <- which(data_raw_save$dtcens <= t & data_raw_save$dtcens_s == 0)   obs_censored_prior <- which(data_raw_save$dtcens <= t & data_raw_save$dtcens_s == 1)    ###   ### Now create unstabilised probability of (un)censoring weights   ### Note that weights are the probability of being uncensored, so if an individual has low probability of being uncesored,   ### the inervse of this will be big, weighting them strongly   ###    ### First etsimate all individuals a weight of the probability of being uncensored at time t   data_raw_save$pcw <- as.numeric(predict(cens_model, newdata = data_raw_save, type = \"surv\", times = t - s)$.pred_survival)    ### Now we must estimate survival probabilities at the times individuals entered absorbing states prior to t (t - s for landmarking)   ### Identify who these individuals are   data_raw_absorbed_prior <- data_raw_save[obs_absorbed_prior, ]    ### Estimate survival probability at time t (t - s for landmarking)   data_raw_save$pcw[obs_absorbed_prior] <- unlist(lapply(1:nrow(data_raw_absorbed_prior),                                                          function(x) {dplyr::pull(predict(cens_model,                                                                                           newdata = data_raw_absorbed_prior[x, ],                                                                                           times = as.numeric(data_raw_absorbed_prior[x, \"dtcens_modified\"]),                                                                                           type = \"survival\"),                                                                                   .pred_survival)}   ))    ### For individuals who were censored prior to t, assign the weight as NA   data_raw_save$pcw[obs_censored_prior] <- NA    ### Invert these   data_raw_save$ipcw <- 1/data_raw_save$pcw    ### Create output object     data_raw_save$ipcw <- pmin(data_raw_save$ipcw, max_weight)     output_weights <- data.frame(\"id\" = data_raw_save$id, \"ipcw\" = data_raw_save$ipcw)    return(output_weights)  } ebmtcal$ipcw_fp <- calc_weights_flexsurv(data_ms = msebmtcal,                                  data_raw = ebmtcal,                                  covs = c(\"year\", \"agecl\", \"proph\", \"match\"),                                  t = t_eval, s = 0, j = 1,                                  max_follow = t_eval)$ipcw ebmtcal |>   ggplot(aes(ipcw_fp)) + geom_histogram() ## `stat_bin()` using `bins = 30`. Pick better value with `binwidth`. ## Warning: Removed 501 rows containing non-finite outside the scale range ## (`stat_bin()`). ### Define predicted transition probabilities out of state j = 1 at time s = 0 tp_pred_s0 <- tps0 |>   dplyr::filter(j == 1) |>   dplyr::select(any_of(paste(\"pstate\", 1:6, sep = \"\")))  ### Estimate calibration curves  # Default, coxph function for estimating the weights dat_calib_blr_coxph <-   calib_msm(data_ms = msebmtcal,             data_raw = ebmtcal,             j=1,             s=0,             t = t_eval,             tp_pred = tp_pred_s0,             calib_type = \"blr\",             curve_type = \"rcs\",             rcs_nk = 3,             w_covs = c(\"year\", \"agecl\", \"proph\", \"match\"),             w_max_follow = 1826)  # Using flexible parametric function for estimating the weights dat_calib_blr_flexsurv <-   calib_msm(data_ms = msebmtcal,             data_raw = ebmtcal,             j=1,             s=0,             t = t_eval,             tp_pred = tp_pred_s0,             calib_type = \"blr\",             curve_type = \"rcs\",             rcs_nk = 3,             w_covs = c(\"year\", \"agecl\", \"proph\", \"match\"),             w_function = calc_weights_flexsurv,             w_max_follow = 1826,             covs_tv = list(\"year\")) grid::grid.draw(plot(dat_calib_blr_coxph)) grid::grid.draw(plot(dat_calib_blr_flexsurv))"},{"path":"https://alexpate30.github.io/calibmsm/articles/Sensitivity-analysis-for-IPCWs.html","id":"conditional-independence-of-the-censoring-mechanism-and-the-outcome-process","dir":"Articles","previous_headings":"","what":"Conditional independence of the censoring mechanism and the outcome process","title":"Sensitivity-analyses-for-IPCWs","text":"BLR-IPCW MLR-IPCW approaches assume outcome, Ik(t)I_{k}(t), independent censoring mechanism re-weighted population. can thought conditional independence outcome censoring mechanism given weights. explore assumption number steps.","code":""},{"path":"https://alexpate30.github.io/calibmsm/articles/Sensitivity-analysis-for-IPCWs.html","id":"exploration-of-the-rate-of-censoring-out-of-each-state","dir":"Articles","previous_headings":"Conditional independence of the censoring mechanism and the outcome process","what":"Exploration of the rate of censoring out of each state","title":"Sensitivity-analyses-for-IPCWs","text":"start looking individuals pass states 1, 2, 3 4, see proportion individuals remain states censored: see far fewer individuals remain adverse event state (19%) censored compared states (33.4% 63.3%). However, ‚Äôs difficult interpret , censoring heavily impacted competing risks events. information measure look proportion individuals censored state, censored within 5-years. see individuals censored states 1, 2 4, 40% censored prior 5-years. However, individuals censored adverse event state (state 3), 17.6% censored within 5-years. data, seeing individuals remain adverse event state, less likely censored. fully understand data observation process, stretch imagine individuals adverse event, recovered, monitored longer periods time, resulting fewer censored within 5-years.","code":"ebmtcal |>   summarise(     n = n(),     prop.cens = mean(as.numeric(ae.s == 0 & rec.s == 0 & recae.s == 0 & srv.s == 0 & rel.s == 0))) ##      n prop.cens ## 1 2279 0.1456779 ebmtcal |>   filter(rec.s == 1) |>   summarise(     n = n(),     prop.cens = mean(as.numeric(recae.s == 0 & srv.s == 0 & rel.s == 0))) ##      n prop.cens ## 1 1218 0.3341544 ebmtcal |>   filter(ae.s == 1) |>   summarise(     n = n(),     prop.cens = mean(as.numeric(recae.s == 0 & srv.s == 0 & rel.s == 0))) ##      n prop.cens ## 1 1134 0.1948854 ebmtcal |>   filter(recae.s == 1) |>   summarise(     n = n(),     prop.cens = mean(as.numeric(srv.s == 0 & rel.s == 0))) ##     n prop.cens ## 1 660  0.630303 ebmtcal |>   filter(ae.s == 0 & rec.s == 0 & recae.s == 0 & srv.s == 0 & rel.s == 0) |>   summarise(n = n(), mean.fup = mean(dtcens),             mean.fup.lower.1826 = mean(dtcens < 1826)) ##     n mean.fup mean.fup.lower.1826 ## 1 332 2392.286           0.3795181 ebmtcal |>   filter(rec.s == 1 & recae.s == 0 & srv.s == 0 & rel.s == 0) |>   summarise(n = n(), mean.fup = mean(dtcens),             mean.fup.lower.1826 = mean(dtcens < 1826)) ##     n mean.fup mean.fup.lower.1826 ## 1 407 2259.007           0.4152334 ebmtcal |>   filter(ae.s == 1 & recae.s == 0 & srv.s == 0 & rel.s == 0) |>   summarise(n = n(), mean.fup = mean(dtcens),             mean.fup.lower.1826 = mean(dtcens < 1826)) ##     n mean.fup mean.fup.lower.1826 ## 1 221 3082.977           0.1764706 ebmtcal |>   filter(recae.s == 1 & srv.s == 0 & rel.s == 0) |>   summarise(n = n(), mean.fup = mean(dtcens),             mean.fup.lower.1826 = mean(dtcens < 1826)) ##     n mean.fup mean.fup.lower.1826 ## 1 416 2366.279           0.3894231"},{"path":"https://alexpate30.github.io/calibmsm/articles/Sensitivity-analysis-for-IPCWs.html","id":"is-this-differential-censoring-driven-by-differences-in-baseline-predictors","dir":"Articles","previous_headings":"Conditional independence of the censoring mechanism and the outcome process","what":"Is this differential censoring driven by differences in baseline predictors?","title":"Sensitivity-analyses-for-IPCWs","text":"point, consider possibility year highly predictive adverse event, know year highly predictive follow time . case, relationship explained variable available baseline, however, see adverse events quite similar across different year categories: also look distribution variables across adverse event. therefore looking like explained information available baseline.","code":"ebmtcal |> group_by(year) |> summarise(mean(ae.s)) ## # A tibble: 3 √ó 2 ##   year      `mean(ae.s)` ##   <fct>            <dbl> ## 1 1985-1989        0.475 ## 2 1990-1994        0.522 ## 3 1995-1998        0.487 ebmtcal |> group_by(agecl) |> summarise(mean(ae.s)) ## # A tibble: 3 √ó 2 ##   agecl `mean(ae.s)` ##   <fct>        <dbl> ## 1 <=20         0.445 ## 2 20-40        0.514 ## 3 >40          0.517 ebmtcal |> group_by(proph) |> summarise(mean(ae.s)) ## # A tibble: 2 √ó 2 ##   proph `mean(ae.s)` ##   <fct>        <dbl> ## 1 no           0.520 ## 2 yes          0.428 ebmtcal |> group_by(match) |> summarise(mean(ae.s)) ## # A tibble: 2 √ó 2 ##   match              `mean(ae.s)` ##   <fct>                     <dbl> ## 1 no gender mismatch        0.499 ## 2 gender mismatch           0.492"},{"path":"https://alexpate30.github.io/calibmsm/articles/Sensitivity-analysis-for-IPCWs.html","id":"distribution-of-weights-by-outcome-state-at-5-years","dir":"Articles","previous_headings":"Conditional independence of the censoring mechanism and the outcome process","what":"Distribution of weights by outcome state at 5-years","title":"Sensitivity-analyses-for-IPCWs","text":"individuals state 3 less likely censored states 1, 2 4, individuals spent long time state 3 need upweighted much. Using inverse probability censoring weights estimated earlier, take mean weight, grouped outcome state individuals 5-years. start identifying state individual 5-years. calculate mean weight within group: Given differential rate censoring within 5-years (17% vs 40%), require weights individuals state 3 5-years considerably lower states 1, 2 4. Note proxy, individuals state 4 may spent time state 3, however, expect bigger differences observed . therefore likely inverse probability censoring weights incorrect, however, due violation proportional hazards assumption previously thought. BLR-IPCW MLR-IPCW approaches assume conditional independence outcome censoring distribution given weights. underlying assumption upon inverse probability censoring based. far, proposed estimating weights conditional vector covariates collected baseline, Z. weights estimated modelling time censoring conditional vector baseline covariates Z, effectively becomes conditional independence given (function ) Z. Indeed, assumption holds, proposed methodology works fine, shown trough simulations.(Pate et al. 2024) However, something considered censoring mechanism changes depending state individual . setting, conditional dependence outcome censoring mechanism given weights estimated baseline covariates alone may hard achieve, unless baseline covariates highly predictive states upon individuals enter. believe likely happening setting. ‚Äôs possible mitigated using complex models estimate IPCWs, latent class model, probability censoring dependent outcome state individual . However, much deeper thought required around notion, simulation studies required establish performance approach. Note probability censoring changes depending outcome state individual present , believe violate assumption Aalen-Johansen estimator, require ‚Äúsubjects censored time t representative study subjects remained risk time t respect survival experience‚Äù.(Kleinbaum Klein 2012). However, , beneficial establish simulation study. now, like emphasise users order implement BLR-IPCW MLR-IPCW approaches, essential outcome censoring mechanism conditionally independent given set baseline covariates ùêô\\mathbf{Z}, whether via weighting IPCW, grouping pseudo-value approach. censoring probability, observation process, changes depending outcome state individuals , can cause bias estimation calibration curves unless properly accounted estimating weights.","code":"### Extract which state individuals are in at time t ids_state_list <- vector(\"list\", 6) for (k in 1:6){   ids_state_list[[k]] <- calibmsm:::extract_ids_states(msebmtcal, tmat = attributes(msebmtcal)$trans, k, t_eval) }  ### Create a variable to say which state an individual was in at the time of interest ## Create list containing the relevant data v1 <- ebmtcal$id m1 <- outer(v1, ids_state_list, FUN = Vectorize('%in%')) state_poly <- lapply(split(m1, row(m1)), function(x) (1:6)[x])  ## Change integer(0) values to NA's idx <- !sapply(state_poly, length) state_poly[idx] <- NA  ## Add to ebmtcal ebmtcal <- dplyr::mutate(ebmtcal, state_poly = unlist(state_poly),                           state_poly_fac = factor(state_poly)) ebmtcal |> group_by(state_poly) |> summarise(mean_weight = mean(ipcw_ph)) ## # A tibble: 7 √ó 2 ##   state_poly mean_weight ##        <int>       <dbl> ## 1          1        1.32 ## 2          2        1.52 ## 3          3        1.47 ## 4          4        1.64 ## 5          5        1.05 ## 6          6        1.03 ## 7         NA       NA"},{"path":"https://alexpate30.github.io/calibmsm/authors.html","id":null,"dir":"","previous_headings":"","what":"Authors","title":"Authors and Citation","text":"Alexander Pate. Author, maintainer, copyright holder. Glen P Martin. Funder, reviewer.","code":""},{"path":"https://alexpate30.github.io/calibmsm/authors.html","id":"citation","dir":"","previous_headings":"","what":"Citation","title":"Authors and Citation","text":"Pate , Sperrin M, Riley RD, Peek N, Van Staa T, Sergeant JC, Mamas MA, Lip GYH, O'Flaherty M, Barrowman M, Buchan , Martin GP (2024). ‚ÄúCalibration plots multistate risk prediction models.‚Äù Statistics Medicine. doi:10.1002/sim.10094, https://onlinelibrary.wiley.com/doi/10.1002/sim.10094.","code":"@Article{,   title = {Calibration plots for multistate risk prediction models},   author = {Alexander Pate and Matthew Sperrin and Richard D. Riley and Niels Peek and Tjeerd {Van Staa} and Jamie C. Sergeant and Mamas A. Mamas and Gregory Y. H. Lip and Martin O'Flaherty and Michael Barrowman and Iain Buchan and Glen P. Martin},   journal = {Statistics in Medicine},   year = {2024},   doi = {10.1002/sim.10094},   url = {https://onlinelibrary.wiley.com/doi/10.1002/sim.10094}, }"},{"path":"https://alexpate30.github.io/calibmsm/index.html","id":"calibmsm","dir":"","previous_headings":"","what":"Calibration Plots for the Transition Probabilities from Multistate Models","title":"Calibration Plots for the Transition Probabilities from Multistate Models","text":"goal calibmsm provide set tools estimating calibration plots validating existing (.e.¬†previously developed) multistate model. vignettes articles package focus assessing calibration multistate model, calibration plots can also produced predicted risks dynamic models, landmark super models, competing risks models standard single outcome survival models, predictions can made landmark time. detailed guide use calibmsm please see Overview vignette.","code":""},{"path":"https://alexpate30.github.io/calibmsm/index.html","id":"installation","dir":"","previous_headings":"","what":"Installation","title":"Calibration Plots for the Transition Probabilities from Multistate Models","text":"package can installed CRAN follows: can install development version calibmsm GitHub :","code":"install.packages(\"calibmsm\") # install.packages(\"devtools\") devtools::install_github(\"alexpate30/calibmsm\")"},{"path":"https://alexpate30.github.io/calibmsm/index.html","id":"example","dir":"","previous_headings":"","what":"Example","title":"Calibration Plots for the Transition Probabilities from Multistate Models","text":"basic example shows assess calibration transition probabilities 5 years follow individuals state j = 1 time s = 0 using BLR-IPCW approach. Please see Overview vignette examples assess calibration using pseudo-value MLR-IPCW approaches, well details methodology. predicted transition probabilities stored tps0, individuals data stored ebmtcal, data msdata format stored msebmtcal. Calibration curves estimated using calib_msm using BLR-IPCW method (calib.type = 'blr') inverse probability censoring weights calculated based variables year, age, prophylaxis donor gender match. calibration curves estimated using restricted cubic splines 3 knots. 95% confidence interval calculated using bootstrapping 200 bootstrap replicates.","code":"## Load calibmsm library(calibmsm)  ## Extract relevant predicted risks from tps0 tp.pred <- dplyr::select(dplyr::filter(tps0, j == 1), any_of(paste(\"pstate\", 1:6, sep = \"\")))  ## Calculate observed event probabilities dat.calib.blr <-   calib_msm(data.ms = msebmtcal,           data.raw = ebmtcal,           j = 1,           s = 0,           t = 1826,           tp.pred = tp.pred,           calib.type = \"blr\",           curve.type = \"rcs\",           rcs.nk = 3,           w.covs = c(\"year\", \"agecl\", \"proph\", \"match\"),           CI = 95,           CI.R.boot = 200)   ## Plot calibration plots plot(dat.calib.blr, combine = TRUE, nrow = 2, ncol = 3, axis.titles.x = c(4,5,6), axis.titles.y = c(1,4))"},{"path":"https://alexpate30.github.io/calibmsm/index.html","id":"getting-help","dir":"","previous_headings":"","what":"Getting help","title":"Calibration Plots for the Transition Probabilities from Multistate Models","text":"encounter bug, please file issue minimal reproducible example GitHub.","code":""},{"path":"https://alexpate30.github.io/calibmsm/reference/calc_weights.html","id":null,"dir":"Reference","previous_headings":"","what":"Calculate inverse probability of censoring weights at time t. ‚Äî calc_weights","title":"Calculate inverse probability of censoring weights at time t. ‚Äî calc_weights","text":"Estimates inverse probability censoring weights fitting cox-propotinal hazards model landmark cohort individuals. Primarily used internally, function exported allow users reproduce results vignette estimating confidence intervals using bootstrapping manually.","code":""},{"path":"https://alexpate30.github.io/calibmsm/reference/calc_weights.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Calculate inverse probability of censoring weights at time t. ‚Äî calc_weights","text":"","code":"calc_weights(   data_ms,   data_raw,   covs = NULL,   t,   s,   landmark_type = \"state\",   j = NULL,   max_weight = 10,   stabilised = FALSE,   max_follow = NULL )"},{"path":"https://alexpate30.github.io/calibmsm/reference/calc_weights.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Calculate inverse probability of censoring weights at time t. ‚Äî calc_weights","text":"data_ms Validation data msdata format data_raw Validation data data.frame (one row per individual) covs Character vector variable names adjust calculating inverse probability censoring weights t Follow time calculate weights s Landmark time predictions made landmark_type Whether weights estimated individuals uncensored time s ('') individuals uncensored state j time s ('state') j Landmark state predictions made (required landmark_type = 'state') max_weight Maximum bound weights stabilised Indicates whether weights stabilised max_follow Maximum follow model calculating inverse probability censoring weights. Reducing t + 1 may aid proportional hazards assumption met model.","code":""},{"path":"https://alexpate30.github.io/calibmsm/reference/calc_weights.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Calculate inverse probability of censoring weights at time t. ‚Äî calc_weights","text":"data frame two columns. id corresponds patient ids data_raw. ipcw contains inverse probability censoring weights (specifically inverse probability uncesored). stabilised = TRUE specified, third variable ipcw_stab returned, stabilised inverse probability censoring weights.","code":""},{"path":"https://alexpate30.github.io/calibmsm/reference/calc_weights.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Calculate inverse probability of censoring weights at time t. ‚Äî calc_weights","text":"Estimates inverse probability censoring weights (Hernan M, Robins J, 2020). Fits cox proportional hazards model individuals landmark cohort, predicting probability censored time t. landmark cohort may either individuals uncensored time s, uncensored state j time s. predictors w_covs assumed linear effect hazard. Weights estimated individuals data_raw, even used analysis meet landmarking requirements. individual enters absorbing state prior t, estimate probability censored time entry absorbing state, rather t. Details provided vignette overview.","code":""},{"path":"https://alexpate30.github.io/calibmsm/reference/calc_weights.html","id":"references","dir":"Reference","previous_headings":"","what":"References","title":"Calculate inverse probability of censoring weights at time t. ‚Äî calc_weights","text":"Hernan M, Robins J (2020). ‚Äú12.2 Estimating IP weights via modeling.‚Äù Causal Inference: , chapter 12.2. Chapman Hall/CRC, Boca Raton.","code":""},{"path":"https://alexpate30.github.io/calibmsm/reference/calc_weights.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Calculate inverse probability of censoring weights at time t. ‚Äî calc_weights","text":"","code":"# Estimate inverse probability of censoring weights for individual in cohort ebmtcal. # Specifically the probability of being uncensored at t = 1826 days. # Weights are estimated using a model fitted in all individuals uncensored at time s = 0. weights_manual <- calc_weights(data_ms = msebmtcal,   data_raw = ebmtcal,   covs = c(\"year\", \"agecl\", \"proph\", \"match\"),   t = 1826,   s = 0,   landmark_type = \"state\",   j = 1)   str(weights_manual) #> 'data.frame':\t2279 obs. of  2 variables: #>  $ id  : int  1 2 3 4 5 6 7 8 9 10 ... #>  $ ipcw: num  NA 1.14 NA 1.01 1.03 ..."},{"path":"https://alexpate30.github.io/calibmsm/reference/calib_msm.html","id":null,"dir":"Reference","previous_headings":"","what":"Assess the calibration of a multistate model ‚Äî calib_msm","title":"Assess the calibration of a multistate model ‚Äî calib_msm","text":"Calculates underlying data calibration plots predicted transition probabilities multistate model using three methods. BLR-IPCW: Binary logistic regression inverse probability censoring weights. MLR-IPCW: Multinomial logistic regression inverse probability censoring weights, based nominal calibration  framework van Hoorde et al. (2014, 2015) Pseudo-values: Pseudo-values estimated using Aalen-Johansen estimator (Aalen OO, Johansen S, 1978).","code":""},{"path":"https://alexpate30.github.io/calibmsm/reference/calib_msm.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Assess the calibration of a multistate model ‚Äî calib_msm","text":"","code":"calib_msm(   data_ms,   data_raw,   j,   s,   t,   tp_pred,   tp_pred_plot = NULL,   calib_type = \"blr\",   curve_type = \"rcs\",   rcs_nk = 3,   loess_span = 0.75,   loess_degree = 2,   loess_surface = c(\"interpolate\", \"direct\"),   loess_statistics = c(\"approximate\", \"exact\", \"none\"),   loess_trace_hat = c(\"exact\", \"approximate\"),   loess_cell = 0.2,   loess_iterations = 4,   loess_iterTrace = FALSE,   mlr_smoother_type = c(\"sm.ps\", \"sm.os\", \"s\"),   mlr_ps_int = 4,   mlr_degree = 3,   mlr_s_df = 4,   mlr_niknots = 4,   weights = NULL,   w_function = NULL,   w_covs = NULL,   w_landmark_type = \"state\",   w_max = 10,   w_stabilised = FALSE,   w_max_follow = NULL,   pv_group_vars = NULL,   pv_n_pctls = NULL,   pv_precalc = NULL,   pv_ids = NULL,   CI = FALSE,   CI_type = \"bootstrap\",   CI_R_boot = NULL,   CI_seed = NULL,   transitions_out = NULL,   assess_moderate = TRUE,   assess_mean = TRUE,   ... )"},{"path":"https://alexpate30.github.io/calibmsm/reference/calib_msm.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Assess the calibration of a multistate model ‚Äî calib_msm","text":"data_ms Validation data msdata format data_raw Validation data data.frame (one row per individual) j Landmark state predictions made s Landmark time predictions made t Follow time calibration assessed tp_pred Data frame matrix predicted transition probabilities time t, state j time s. must separate column predicted transition probabilities every state, even predicted transition probabilities 0. tp_pred_plot Data frame matrix predicted risks possible transition plot calibration curves. Argument provided enable user apply bootstrapping manually. calib_type Whether calibration plots estimated using BLR-IPCW ('blr'), MLR-IPCW ('mlr') pseudo-values ('pv') curve_type Whether calibration curves estimated using restricted cubic splines ('rcs') loess smoothers ('loess') rcs_nk Number knots curves estimated using restricted cubic splines loess_span Span curves estimated using loess smoothers loess_degree Degree curves estimated_ using loess smoothers loess_surface see loess.control loess_statistics see loess.control loess_trace_hat see loess.control loess_cell see loess.control loess_iterations see loess.control loess_iterTrace see loess.control mlr_smoother_type Type smoothing applied. Takes values s (see s), sm.ps (see sm.ps) sm.os (see sm.os). mlr_ps_int number equally-spaced B spline intervals vector spline smoother (see sm.ps) mlr_degree degree B-spline basis vector spline smoother (see sm.ps) mlr_s_df degrees freedom vector spline (see s) mlr_niknots number interior knots (see sm.os) weights Vector inverse probability censoring weights w_function Custom function estimating inverse probability censoring weights w_covs Character vector variable names adjust calculating inverse probability censoring weights w_landmark_type Whether weights estimated individuals uncensored time s ('') individuals uncensored state j time s ('state') w_max Maximum bound inverse probability censoring weights w_stabilised Indicates whether inverse probability censoring weights stabilised w_max_follow Maximum follow model calculating inverse probability censoring weights. Reducing t + 1 may aid proportional hazards assumption met model. pv_group_vars Variables group calculating pseudo-values pv_n_pctls Number percentiles predicted risk group calculating pseudo-values pv_precalc Pre-calculated pseudo-values pv_ids Id's individuals calculate pseudo-values CI Size confidence intervals % CI_type Method estimating confidence interval (currently restricted bootstrap) CI_R_boot Number bootstrap replicates estimating confidence interval calibration curve CI_seed Seed bootstrapping procedure transitions_out Transitions calculate calibration curves. possible transitions left NULL. assess_moderate TRUE/FALSE whether estimate data calibration plots assess_mean TRUE/FALSE whether estimate mean calibration ... Extra arguments passed w_function (custom function estimating weights)","code":""},{"path":"https://alexpate30.github.io/calibmsm/reference/calib_msm.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Assess the calibration of a multistate model ‚Äî calib_msm","text":"calib_msm returns list containing two elements: plotdata metadata. plotdata element contains data calibration plots. list element containing calibration plot data transition probabilities possible states. list element contains patient ids (id) data_raw, predicted transition probabilities (pred) estimated observed event probabilities (obs). confidence interval requested, upper (obs_upper) lower (obs_lower) bounds observed event probabilities also returned. tp_pred_plot specified, column (id) returned. metadata element contains metadata including: vector possible transitions, vector transitions calibration curves estimated , size confidence interval, method estimating calibration curve user specified information.","code":""},{"path":"https://alexpate30.github.io/calibmsm/reference/calib_msm.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Assess the calibration of a multistate model ‚Äî calib_msm","text":"Observed event probabilities time t estimated predicted transition probabilities tp_pred state j time s. calib_type = 'blr' estimates calibration curves using techniques assessing calibration binary logistic regression model (Van Calster et al., 2016). choice restricted cubic splines loess smoothers estimating calibration curve can made using curve_type. Landmarking (van Houwelingen HC, 2007) applied assess calibration individuals uncensored state j time s. Calibration can assessed individuals also uncensored time t, accounted using inverse probability censoring weights (Hernan M, Robins J, 2020). See method BLR-IPCW Pate et al., (2024) full explanation approach. calib_type = 'mlr' estimates calibration scatter plots using technique assessing calibration multinomial logistic regression models, namely nominal calibration framework van Hoorde et al. (2014, 2015). Landmarking (van Houwelingen HC, 2007) applied assess calibration individuals uncensored state j time s. Calibration can assessed individuals also uncensored time t, accounted using inverse probability censoring weights (Hernan M, Robins J, 2020). See method BLR-IPCW Pate et al., (2024) full explanation approach. calib_type = 'pv' estimates calibration curves using using pseudo-values (Andersen PK, Pohar Perme M, 2010) calculated using Aalen-Johansen estimator (Aalen OO, Johansen S, 1978). Calibration curves generated regressing pseudo-values predicted transition probabilities. choice restricted cubic splines loess smoothers estimating calibration curve can made using curve_type. Landmarking (van Houwelingen HC, 2007) applied assess calibration individuals uncensored state j time s. nature pseudo-values means calibration can assessed landmarked individuals, regardless censoring time. See method Pseudo-value approach Pate et al., (2024) full explanation approach. Two datasets cohort inidividuals must provided. Firstly, data_raw must data.frame one row per individual containing variables time censoring (dtcens), indicator censoring dtcens_s, (dtcens_s = 1) individual censored time dtcens, dtcens_s = 0 otherwise. individual enters absorbing state, prevents censoring happening (.e. dtcens_s = 0). data_raw must also contain desired variables estimating weights. Secondly, data_ms must dataset class msdata, generated using [mstate] package. dataset used apply landmarking identify state individuals time t. data_ms can derived data_raw, inefficient within calibmsm::calib_msm due bootstrapping procedure, therefore must inputted seperately. Unless user specifies weights using weights, weights estimated using cox-proportional hazard model, assuming linear functional form variables defined w_covs. urge users specify model estimating weights. weights argument must vector length equal number rows data_raw. Confidence intervals produced calibration scatter plots (calib_type = 'mlr'). calibration curves estimated using calib_type = 'blr', confidence intervals can estimated using bootstrapping (CI_type = 'bootstrap). procedure uses internal method estimating weights, therefore encourage users specify bootstrapping procedure, incorporates model estimating weights. Details provided vignette BLR-IPCW-manual-bootstrap. calibration curves estimated using calib_type = 'pv', confidence intervals can estimated using bootstrapping (CI_type = 'bootstrap) parametric formulae (CI_type = 'parametric). computational reasons recommend using parametric approach. calibration plots can plotted using plot.calib_msm plot.calib_mlr.","code":""},{"path":"https://alexpate30.github.io/calibmsm/reference/calib_msm.html","id":"references","dir":"Reference","previous_headings":"","what":"References","title":"Assess the calibration of a multistate model ‚Äî calib_msm","text":"Aalen OO, Johansen S. Empirical Transition Matrix Non-Homogeneous Markov Chains Based Censored Observations. Scand J Stat. 1978;5(3):141-150. Andersen PK, Pohar Perme M. Pseudo-observations survival analysis. Stat Methods Med Res. 2010;19(1):71-99. doi:10.1177/0962280209105020 Hernan M, Robins J (2020). ‚Äú12.2 Estimating IP weights via modeling.‚Äù Causal Inference: , chapter 12.2. Chapman Hall/CRC, Boca Raton. Pate, ., Sperrin, M., Riley, R. D., Peek, N., Van Staa, T., Sergeant, J. C., Mamas, M. ., Lip, G. Y. H., Flaherty, M. O., Barrowman, M., Buchan, ., & Martin, G. P. Calibration plots multistate risk predictions models. Statistics Medicine. 2024;April:1‚Äì23. doi: 10.1002/sim.10094. Van Calster B, Nieboer D, Vergouwe Y, De Cock B, Pencina MJ, Steyerberg EW (2016). ‚Äúcalibration hierarchy risk models defined: utopia empirical data.‚Äù Journal Clinical Epidemiology, 74, 167‚Äì176. ISSN 18785921. doi:10.1016/j.jclinepi.2015. 12.005. URL http://dx.doi.org/10.1016/j.jclinepi.2015.12.005 Van Hoorde K, Vergouwe Y, Timmerman D, Van Huffel S, Steyerberg W, Van Calster B (2014). ‚ÄúAssessing calibration multinomial risk prediction models.‚Äù Statistics Medicine, 33(15), 2585‚Äì2596. doi:10.1002/sim.6114. Van Hoorde K, Van Huffel S, Timmerman D, Bourne T, Van Calster B (2015). ‚Äúspline-based tool assess visualize calibration multiclass risk predictions.‚Äù Journal Biomedical Informatics, 54, 283‚Äì293. ISSN 15320464. doi:10.1016/j.jbi.2014.12.016. URL http://dx.doi.org/10.1016/j.jbi.2014.12.016. van Houwelingen HC (2007). ‚ÄúDynamic Prediction Landmarking Event History Analysis.‚Äù Scandinavian Journal Statistics, 34(1), 70‚Äì85. Yee TW (2015). Vector Generalized Linear Additive Models. 1 edition. Springer New, NY. ISBN 978-1-4939-4198-8. doi:10.1007/978-1-4939-2818-7. URL https://link.springer.com/book/10.1007/978-1-4939-2818-7.","code":""},{"path":"https://alexpate30.github.io/calibmsm/reference/calib_msm.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Assess the calibration of a multistate model ‚Äî calib_msm","text":"","code":"# Estimate BLR-IPCW calibration curves for the predicted transition # probabilities at time t = 1826, when predictions were made at time # s = 0 in state j = 1. These predicted transition probabilities are stored in tps0.  # Extract the predicted transition probabilities out of state j = 1 tp_pred <- dplyr::select(dplyr::filter(tps0, j == 1), any_of(paste(\"pstate\", 1:6, sep = \"\")))  # Now estimate the observed event probabilities for each possible transition. dat_calib <- calib_msm(data_ms = msebmtcal,  data_raw = ebmtcal,  j=1,  s=0,  t = 1826,  tp_pred = tp_pred,  w_covs = c(\"year\", \"agecl\", \"proph\", \"match\"))  # Summarise the output summary(dat_calib) #> The method used to assess calibration was BLR-IPCW #>  #> There were non-zero predicted transition probabilities into states  1,2,3,4,5,6 #>  #> Calibration curves have been estimated for transitions into states  1,2,3,4,5,6 #>  #> Calibration was assessed at time 1826 and calibration was assessed in a landmarked cohort of individuals in state j = 1 at time s = 0 #>  #> A confidence interval was not estimated #>  #> The estimated data for calibration plots are stored in list element `plotdata`: #>  #> $state1 #>   id      pred       obs #> 2  2 0.1140189 0.1095897 #> 4  4 0.1383878 0.1036308 #>  #> $state2 #>   id      pred       obs #> 2  2 0.2316569 0.1698031 #> 4  4 0.1836189 0.1855591 #>  #> $state3 #>   id       pred       obs #> 2  2 0.08442692 0.1248583 #> 4  4 0.07579429 0.1166606 #>  #> $state4 #>   id      pred       obs #> 2  2 0.2328398 0.2427580 #> 4  4 0.2179331 0.2243106 #>  #> $state5 #>   id      pred       obs #> 2  2 0.1481977 0.1909795 #> 4  4 0.1538475 0.1654523 #>  #> $state6 #>   id      pred       obs #> 2  2 0.1888598 0.2069354 #> 4  4 0.2304185 0.2542212 #>  #>  #>  #> The estimated mean calibration are stored in list element `mean`: #>  #>        state1        state2        state3        state4        state5  #> -0.0216273416 -0.0152282576  0.0254839288  0.0097158314 -0.0003011927  #>        state6  #>  0.0032309988"},{"path":"https://alexpate30.github.io/calibmsm/reference/calibmsm-package.html","id":null,"dir":"Reference","previous_headings":"","what":"calibmsm: Calibration Plots for the Transition Probabilities from Multistate Models ‚Äî calibmsm-package","title":"calibmsm: Calibration Plots for the Transition Probabilities from Multistate Models ‚Äî calibmsm-package","text":"Assess calibration existing (.e. previously developed) multistate model calibration plots. Calibration assessed using one three methods. 1) Calibration methods binary logistic regression models applied fixed time point conjunction inverse probability censoring weights. 2) Calibration methods multinomial logistic regression models applied fixed time point conjunction inverse probability censoring weights. 3) Pseudo-values estimated using Aalen-Johansen estimator observed risk. methods applied conjunction landmarking required. calibration plots evaluate calibration (validation cohort interest) transition probabilities estimated existing multistate model. package development focused multistate models, calibration plots can produced model utilises information post baseline update predictions (e.g. dynamic models); competing risks models; standard single outcome survival models, predictions can made landmark time. Please see Pate et al. (2024) doi:10.1002/sim.10094  Pate et al. (2024) https://alexpate30.github.io/calibmsm/articles/Overview.html.","code":""},{"path":[]},{"path":"https://alexpate30.github.io/calibmsm/reference/calibmsm-package.html","id":"author","dir":"Reference","previous_headings":"","what":"Author","title":"calibmsm: Calibration Plots for the Transition Probabilities from Multistate Models ‚Äî calibmsm-package","text":"Maintainer: Alexander Pate alexander.pate@manchester.ac.uk (ORCID) [copyright holder] contributors: Glen P Martin glen.martin@manchester.ac.uk (ORCID) [funder, reviewer]","code":""},{"path":"https://alexpate30.github.io/calibmsm/reference/ebmtcal.html","id":null,"dir":"Reference","previous_headings":"","what":"European Group for Blood and Marrow Transplantation data (one row per individual) ‚Äî ebmtcal","title":"European Group for Blood and Marrow Transplantation data (one row per individual) ‚Äî ebmtcal","text":"data frame 2,279 individuals blood cancer undergone transplant. data identical ebmt4 data, except two extra variables derived, time censoring censoring indicator, required assess calibration using methods calibmsm. Code derivation dataset provided source code package.","code":""},{"path":"https://alexpate30.github.io/calibmsm/reference/ebmtcal.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"European Group for Blood and Marrow Transplantation data (one row per individual) ‚Äî ebmtcal","text":"","code":"ebmtcal"},{"path":[]},{"path":"https://alexpate30.github.io/calibmsm/reference/ebmtcal.html","id":"-ebmtcal-","dir":"Reference","previous_headings":"","what":"'ebmtcal'","title":"European Group for Blood and Marrow Transplantation data (one row per individual) ‚Äî ebmtcal","text":"data frame 2,279 rows 17 columns: id Patient indentifier rec, rec.s Time event indicator recovery variable ae, ae.s Time event indicator adverse event variable recae, recae.s Time event indicator recovery + adverse event variable rel, rel.s Time event indicator relapse variable srv, srv.s Time event indicator death variable year Year transplant agecl Age transplant proph Prophylaxis match Donor-recipient match dtcens Time censoring dtcens_s Event indicator, 1:censoring occured, 0: absorbing state entered censoring occured","code":""},{"path":"https://alexpate30.github.io/calibmsm/reference/ebmtcal.html","id":"source","dir":"Reference","previous_headings":"","what":"Source","title":"European Group for Blood and Marrow Transplantation data (one row per individual) ‚Äî ebmtcal","text":"dataset derived data made available within mstate package, see ebmt4. data originally provided European Group Blood Marrow Transplantation (https://www.ebmt.org/). reiterate source statement given developers mstate: \"acknowledge European Society Blood Marrow Transplantation (EBMT) making available data. Disclaimer: data simplified purpose illustration analysis competing risks multi-state models reflect real life situation. clinical conclusions drawn data.\"","code":""},{"path":"https://alexpate30.github.io/calibmsm/reference/ebmtcal.html","id":"references","dir":"Reference","previous_headings":"","what":"References","title":"European Group for Blood and Marrow Transplantation data (one row per individual) ‚Äî ebmtcal","text":"EBMT (2023). ‚ÄúData European Society Blood Marrow Transplantation.‚Äù URL https://search.r-project.org/CRAN/refmans/mstate/html/EBMT-data.html. de Wreede LC, Fiocco M, Putter H (2011). ‚Äúmstate: R Package Analysis Competing Risks Multi-State Models.‚Äù Journal Statistical Software, 38(7).","code":""},{"path":"https://alexpate30.github.io/calibmsm/reference/ebmtcal_cmprsk.html","id":null,"dir":"Reference","previous_headings":"","what":"European Group for Blood and Marrow Transplantation data (one row per individual) ‚Äî ebmtcal_cmprsk","title":"European Group for Blood and Marrow Transplantation data (one row per individual) ‚Äî ebmtcal_cmprsk","text":"Used vignette/article: Comparison--graphical-calibration-curves--competing-risks-setting.","code":""},{"path":"https://alexpate30.github.io/calibmsm/reference/ebmtcal_cmprsk.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"European Group for Blood and Marrow Transplantation data (one row per individual) ‚Äî ebmtcal_cmprsk","text":"","code":"ebmtcal_cmprsk"},{"path":[]},{"path":"https://alexpate30.github.io/calibmsm/reference/ebmtcal_cmprsk.html","id":"-ebmtcal-cmprsk-","dir":"Reference","previous_headings":"","what":"'ebmtcal_cmprsk'","title":"European Group for Blood and Marrow Transplantation data (one row per individual) ‚Äî ebmtcal_cmprsk","text":"data frame 2,279 rows 17 columns: id Patient indentifier rec, rec.s Time event indicator recovery variable ae, ae.s Time event indicator adverse event variable recae, recae.s Time event indicator recovery + adverse event variable rel, rel.s Time event indicator relapse variable srv, srv.s Time event indicator death variable year Year transplant agecl Age transplant proph Prophylaxis match Donor-recipient match dtcens Time censoring dtcens_s Event indicator, 1:censoring occured, 0: absorbing state entered censoring occured","code":""},{"path":"https://alexpate30.github.io/calibmsm/reference/ebmtcal_cmprsk.html","id":"source","dir":"Reference","previous_headings":"","what":"Source","title":"European Group for Blood and Marrow Transplantation data (one row per individual) ‚Äî ebmtcal_cmprsk","text":"dataset derived data made available within mstate package, see ebmt4. data originally provided European Group Blood Marrow Transplantation (https://www.ebmt.org/). reiterate source statement given developers mstate: \"acknowledge European Society Blood Marrow Transplantation (EBMT) making available data. Disclaimer: data simplified purpose illustration analysis competing risks multi-state models reflect real life situation. clinical conclusions drawn data.\"","code":""},{"path":"https://alexpate30.github.io/calibmsm/reference/ebmtcal_cmprsk.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"European Group for Blood and Marrow Transplantation data (one row per individual) ‚Äî ebmtcal_cmprsk","text":"data frame 2,279 individuals blood cancer undergone transplant. data identical ebmt4 data, except two extra variables derived, time censoring censoring indicator, required assess calibration using methods calibmsm. Specifically, time censoring ar calculated setting competing risks model first state, transitions can made. means entry state (absorbing states) effect preventing censoring occurring, dtcens dtcens_s different values found ebmtcal. dataset designed used alongside dataset msebmtcal_cmprsk, assessing calibration competing risks model. Code derivation dataset provided source code package.","code":""},{"path":"https://alexpate30.github.io/calibmsm/reference/ebmtcal_cmprsk.html","id":"references","dir":"Reference","previous_headings":"","what":"References","title":"European Group for Blood and Marrow Transplantation data (one row per individual) ‚Äî ebmtcal_cmprsk","text":"EBMT (2023). ‚ÄúData European Society Blood Marrow Transplantation.‚Äù URL https://search.r-project.org/CRAN/refmans/mstate/html/EBMT-data.html. de Wreede LC, Fiocco M, Putter H (2011). ‚Äúmstate: R Package Analysis Competing Risks Multi-State Models.‚Äù Journal Statistical Software, 38(7).","code":""},{"path":"https://alexpate30.github.io/calibmsm/reference/metadata.html","id":null,"dir":"Reference","previous_headings":"","what":"Create S3 generic for printing metadata ‚Äî metadata","title":"Create S3 generic for printing metadata ‚Äî metadata","text":"Create S3 generic printing metadata","code":""},{"path":"https://alexpate30.github.io/calibmsm/reference/metadata.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Create S3 generic for printing metadata ‚Äî metadata","text":"","code":"metadata(x, ...)"},{"path":"https://alexpate30.github.io/calibmsm/reference/metadata.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Create S3 generic for printing metadata ‚Äî metadata","text":"x Object generated calib_msm. ... Extra arguments","code":""},{"path":"https://alexpate30.github.io/calibmsm/reference/msebmtcal.html","id":null,"dir":"Reference","previous_headings":"","what":"European Group for Blood and Marrow Transplantation data in msdata format. ‚Äî msebmtcal","title":"European Group for Blood and Marrow Transplantation data in msdata format. ‚Äî msebmtcal","text":"ebmt4 data converted msdata format (see msprep), using processes implemented mstate package. Code derivation dataset provided source code package.","code":""},{"path":"https://alexpate30.github.io/calibmsm/reference/msebmtcal.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"European Group for Blood and Marrow Transplantation data in msdata format. ‚Äî msebmtcal","text":"","code":"msebmtcal"},{"path":[]},{"path":"https://alexpate30.github.io/calibmsm/reference/msebmtcal.html","id":"-msebmtcal-","dir":"Reference","previous_headings":"","what":"'msebmtcal'","title":"European Group for Blood and Marrow Transplantation data in msdata format. ‚Äî msebmtcal","text":"data frame msdata format (see msprep) 15,512 rows 8 columns: id Patient indentifier transition state transition state trans transition number Tstart time entered state '' Tstop time leaving state '' time time state '' status event indicator, 1:transitioned state ''","code":""},{"path":"https://alexpate30.github.io/calibmsm/reference/msebmtcal.html","id":"source","dir":"Reference","previous_headings":"","what":"Source","title":"European Group for Blood and Marrow Transplantation data in msdata format. ‚Äî msebmtcal","text":"dataset derived data made available within mstate package, see ebmt4. data originally provided European Group Blood Marrow Transplantation (https://www.ebmt.org/). reiterate source statement given developers mstate: \"acknowledge European Society Blood Marrow Transplantation (EBMT) making available data. Disclaimer: data simplified purpose illustration analysis competing risks multi-state models reflect real life situation. clinical conclusions drawn data.\"","code":""},{"path":"https://alexpate30.github.io/calibmsm/reference/msebmtcal.html","id":"references","dir":"Reference","previous_headings":"","what":"References","title":"European Group for Blood and Marrow Transplantation data in msdata format. ‚Äî msebmtcal","text":"EBMT (2023). ‚ÄúData European Society Blood Marrow Transplantation.‚Äù URL https://search.r-project.org/CRAN/refmans/mstate/html/EBMT-data.html. de Wreede LC, Fiocco M, Putter H (2011). ‚Äúmstate: R Package Analysis Competing Risks Multi-State Models.‚Äù Journal Statistical Software, 38(7).","code":""},{"path":"https://alexpate30.github.io/calibmsm/reference/msebmtcal_cmprsk.html","id":null,"dir":"Reference","previous_headings":"","what":"European Group for Blood and Marrow Transplantation data in competing risks format, for transitions out of the initial state only ‚Äî msebmtcal_cmprsk","title":"European Group for Blood and Marrow Transplantation data in competing risks format, for transitions out of the initial state only ‚Äî msebmtcal_cmprsk","text":"Used vignette/article: Comparison--graphical-calibration-curves--competing-risks-setting.","code":""},{"path":"https://alexpate30.github.io/calibmsm/reference/msebmtcal_cmprsk.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"European Group for Blood and Marrow Transplantation data in competing risks format, for transitions out of the initial state only ‚Äî msebmtcal_cmprsk","text":"","code":"msebmtcal_cmprsk"},{"path":[]},{"path":"https://alexpate30.github.io/calibmsm/reference/msebmtcal_cmprsk.html","id":"-msebmtcal-cmprsk-","dir":"Reference","previous_headings":"","what":"'msebmtcal_cmprsk'","title":"European Group for Blood and Marrow Transplantation data in competing risks format, for transitions out of the initial state only ‚Äî msebmtcal_cmprsk","text":"data frame 9,116 rows 8 columns: id Patient indentifier transition state transition state trans transition number Tstart time entered state '' Tstop time leaving state '' time time state '' status event indicator, 1:transitioned state ''","code":""},{"path":"https://alexpate30.github.io/calibmsm/reference/msebmtcal_cmprsk.html","id":"source","dir":"Reference","previous_headings":"","what":"Source","title":"European Group for Blood and Marrow Transplantation data in competing risks format, for transitions out of the initial state only ‚Äî msebmtcal_cmprsk","text":"dataset derived data made available within mstate package, see ebmt4. data originally provided European Group Blood Marrow Transplantation (https://www.ebmt.org/). reiterate source statement given developers mstate: \"acknowledge European Society Blood Marrow Transplantation (EBMT) making available data. Disclaimer: data simplified purpose illustration analysis competing risks multi-state models reflect real life situation. clinical conclusions drawn data.\"","code":""},{"path":"https://alexpate30.github.io/calibmsm/reference/msebmtcal_cmprsk.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"European Group for Blood and Marrow Transplantation data in competing risks format, for transitions out of the initial state only ‚Äî msebmtcal_cmprsk","text":"ebmt4 data converted msdata format (see msprep), subsequent states considered absorbing states. .e. transitions initial state considered, meaning data constitutes competing risks model initial state. Code derivation dataset provided source code package.","code":""},{"path":"https://alexpate30.github.io/calibmsm/reference/msebmtcal_cmprsk.html","id":"references","dir":"Reference","previous_headings":"","what":"References","title":"European Group for Blood and Marrow Transplantation data in competing risks format, for transitions out of the initial state only ‚Äî msebmtcal_cmprsk","text":"EBMT (2023). ‚ÄúData European Society Blood Marrow Transplantation.‚Äù URL https://search.r-project.org/CRAN/refmans/mstate/html/EBMT-data.html. de Wreede LC, Fiocco M, Putter H (2011). ‚Äúmstate: R Package Analysis Competing Risks Multi-State Models.‚Äù Journal Statistical Software, 38(7).","code":""},{"path":"https://alexpate30.github.io/calibmsm/reference/plot.calib_mlr.html","id":null,"dir":"Reference","previous_headings":"","what":"Plots calibration scatter plots for objects of class calib_mlr estimated using using calib_msm. ‚Äî plot.calib_mlr","title":"Plots calibration scatter plots for objects of class calib_mlr estimated using using calib_msm. ‚Äî plot.calib_mlr","text":"Plots calibration scatter plots transition probabilities multistate model estimated using MLR-IPCW approach.","code":""},{"path":"https://alexpate30.github.io/calibmsm/reference/plot.calib_mlr.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Plots calibration scatter plots for objects of class calib_mlr estimated using using calib_msm. ‚Äî plot.calib_mlr","text":"","code":"# S3 method for class 'calib_mlr' plot(   x,   ...,   combine = TRUE,   ncol = NULL,   nrow = NULL,   size_point = 0.5,   size_text = 12,   transparency_plot = 0.25,   marg_density = FALSE,   marg_density_size = 5,   marg_density_type = \"density\",   marg_rug = FALSE,   marg_rug_transparency = 0.1,   titles_include = TRUE,   titles = NULL,   axis_titles_x = NULL,   axis_titles_text_x = \"Predicted risk\",   axis_titles_y = NULL,   axis_titles_text_y = \"Predicted-observed risk\" )"},{"path":"https://alexpate30.github.io/calibmsm/reference/plot.calib_mlr.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Plots calibration scatter plots for objects of class calib_mlr estimated using using calib_msm. ‚Äî plot.calib_mlr","text":"x Object class calib_mlr generated calib_msm ... combine Whether combine one plot using ggarrange, return list individual plots ncol Number columns combined calibration plot nrow Number rows combined calibration plot size_point Size points scatter plot size_text Size text plot transparency_plot Degree transparency points calibration scatter plot marg_density Whether produce marginal density plots TRUE/FALSE marg_density_size Size main plot relative density plots (see ggMarginal) marg_density_type type marginal plot show (see ggMarginal) marg_rug Whether produce marginal rug plots TRUE/FALSE marg_rug_transparency Degree transparency density rug plot along axis titles_include Whether include titles individual calibration plots titles Vector titles calibration plots_ Defaults \"State k\" plot_ axis_titles_x Position plots include title x-axis axis_titles_text_x x-axis title axis_titles_y Position plots include title y-axis axis_titles_text_y y-axis title","code":""},{"path":"https://alexpate30.github.io/calibmsm/reference/plot.calib_mlr.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Plots calibration scatter plots for objects of class calib_mlr estimated using using calib_msm. ‚Äî plot.calib_mlr","text":"combine = TRUE, returns object classes gg, ggplot, ggarrange, ggplots combined one object. combine = FALSE, returns object class list, element containing object class gg ggplot.","code":""},{"path":"https://alexpate30.github.io/calibmsm/reference/plot.calib_mlr.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Plots calibration scatter plots for objects of class calib_mlr estimated using using calib_msm. ‚Äî plot.calib_mlr","text":"","code":"# Using competing risks data out of initial state (see vignette: ... -in-competing-risk-setting). # Estimate and plot MLR-IPCW calibration scatter plots for the predicted transition # probabilities at time t = 1826, when predictions were made at time # s = 0 in state j = 1. These predicted transition probabilities are stored in tp_cmprsk_j0.  # To minimise example time we reduce the datasets to 150 individuals. # Extract the predicted transition probabilities out of state j = 1 for first 150 individuals tp_pred <- tp_cmprsk_j0 |>  dplyr::filter(id %in% 1:150) |>  dplyr::select(any_of(paste(\"pstate\", 1:6, sep = \"\"))) # Reduce ebmtcal to first 150 individuals ebmtcal <- ebmtcal |> dplyr::filter(id %in% 1:150) # Reduce msebmtcal_cmprsk to first 150 individuals msebmtcal_cmprsk <- msebmtcal_cmprsk |> dplyr::filter(id %in% 1:150)  # Now estimate the observed event probabilities for each possible transition. dat_calib <- calib_msm(data_ms = msebmtcal_cmprsk,  data_raw = ebmtcal,  j=1,  s=0,  t = 1826,  tp_pred = tp_pred,  calib_type = \"mlr\",  w_covs = c(\"year\", \"agecl\", \"proph\", \"match\"),  mlr_ps_int = 2,  mlr_degree = 2) #> Warning: In the landmark cohort of individuals uncensored and in state j at time s, #>     there are some states have less than 50 people at the time at which calibration is being assessed (t). #>     Warnings and errors may occur when the models are fitted to estimate the calibration curves due to small sample size. #>     This warning has been written to try and intercept some uninformative error messages when the underlying statistical models fail. #>     The number to flag this warning (50) has been chosen arbitrarily, and does not constitute a sufficient sample size from a statistical point of view.   # These are then plotted  plot(dat_calib, combine = TRUE, nrow = 2, ncol = 3)"},{"path":"https://alexpate30.github.io/calibmsm/reference/plot.calib_msm.html","id":null,"dir":"Reference","previous_headings":"","what":"Plots calibration curves estimated using calib_msm. ‚Äî plot.calib_msm","title":"Plots calibration curves estimated using calib_msm. ‚Äî plot.calib_msm","text":"Plots calibration curves transition probabilities multistate model estimated using BLR-IPCW pseudo-value approaches.","code":""},{"path":"https://alexpate30.github.io/calibmsm/reference/plot.calib_msm.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Plots calibration curves estimated using calib_msm. ‚Äî plot.calib_msm","text":"","code":"# S3 method for class 'calib_msm' plot(   x,   ...,   combine = TRUE,   ncol = NULL,   nrow = NULL,   size_line = 0.5,   size_text = 12,   marg_density = TRUE,   marg_density_size = 5,   marg_density_type = \"density\",   marg_rug = FALSE,   marg_rug_transparency = 0.1,   titles_include = TRUE,   titles = NULL,   axis_titles_x = NULL,   axis_titles_text_x = \"Predicted risk\",   axis_titles_y = NULL,   axis_titles_text_y = \"Predicted-observed risk\",   legend_include = TRUE,   legend_seperate = FALSE,   legend_title = NULL,   legend_position = \"bottom\" )"},{"path":"https://alexpate30.github.io/calibmsm/reference/plot.calib_msm.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Plots calibration curves estimated using calib_msm. ‚Äî plot.calib_msm","text":"x Object class 'calib_msm' generated calib_msm. ... combine Whether combine one plot using ggarrange, return list individual plots ncol Number columns combined calibration plot nrow Number rows combined calibration plot size_line Size line plots size_text Size text plot marg_density Whether produce marginal density plots TRUE/FALSE marg_density_size Size main plot relative density plots (see ggMarginal) marg_density_type type marginal plot show (see ggMarginal) marg_rug Whether produce marginal rug plots TRUE/FALSE marg_rug_transparency Degree transparency density rug plot along axis titles_include Whether include titles individual calibration plots titles Vector titles calibration plots. Defaults \"State k\" plot. axis_titles_x Position plots include title x-axis axis_titles_text_x x-axis title axis_titles_y Position plots include title y-axis axis_titles_text_y y-axis title legend_include Whether produce legend legend_seperate = Whether include legend plot (FALSE) seperate object (TRUE) legend_title Title legend legend_position Position legend","code":""},{"path":"https://alexpate30.github.io/calibmsm/reference/plot.calib_msm.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Plots calibration curves estimated using calib_msm. ‚Äî plot.calib_msm","text":"combine = TRUE, returns object classes gg, ggplot, ggarrange, ggplots combined one object. combine = FALSE, returns object class list, element containing object class gg ggplot.","code":""},{"path":"https://alexpate30.github.io/calibmsm/reference/plot.calib_msm.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Plots calibration curves estimated using calib_msm. ‚Äî plot.calib_msm","text":"","code":"# Estimate and plot BLR-IPCW calibration curves for the predicted transition # probabilities at time t = 1826, when predictions were made at time # s = 0 in state j = 1. These predicted transition probabilities are stored in tps0.  # Extract the predicted transition probabilities out of state j = 1 tp_pred <- dplyr::select(dplyr::filter(tps0, j == 1), any_of(paste(\"pstate\", 1:6, sep = \"\")))  # Now estimate the observed event probabilities for each possible transition. dat_calib <- calib_msm(data_ms = msebmtcal,  data_raw = ebmtcal,  j=1,  s=0,  t = 1826,  tp_pred = tp_pred,  w_covs = c(\"year\", \"agecl\", \"proph\", \"match\"))   # These are then plotted  plot(dat_calib, combine = TRUE, nrow = 2, ncol = 3) #> TableGrob (2 x 3) \"arrange\": 6 grobs #>   z     cells    name                grob #> 1 1 (1-1,1-1) arrange ggExtraPlot[layout] #> 2 2 (1-1,2-2) arrange ggExtraPlot[layout] #> 3 3 (1-1,3-3) arrange ggExtraPlot[layout] #> 4 4 (2-2,1-1) arrange ggExtraPlot[layout] #> 5 5 (2-2,2-2) arrange ggExtraPlot[layout] #> 6 6 (2-2,3-3) arrange ggExtraPlot[layout]"},{"path":"https://alexpate30.github.io/calibmsm/reference/tp_cmprsk_j0.html","id":null,"dir":"Reference","previous_headings":"","what":"Predicted risks for a competing risks model out of state j = 0 ‚Äî tp_cmprsk_j0","title":"Predicted risks for a competing risks model out of state j = 0 ‚Äî tp_cmprsk_j0","text":"Used vignette/article: Comparison--graphical-calibration-curves--competing-risks-setting.","code":""},{"path":"https://alexpate30.github.io/calibmsm/reference/tp_cmprsk_j0.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Predicted risks for a competing risks model out of state j = 0 ‚Äî tp_cmprsk_j0","text":"","code":"tp_cmprsk_j0"},{"path":[]},{"path":"https://alexpate30.github.io/calibmsm/reference/tp_cmprsk_j0.html","id":"-tp-cmprsk-j-","dir":"Reference","previous_headings":"","what":"'tp_cmprsk_j0'","title":"Predicted risks for a competing risks model out of state j = 0 ‚Äî tp_cmprsk_j0","text":"data frame 2,279 rows 13 columns: id Patient indentifier pstate1, pstate2, pstate3, pstate4, pstate5, pstate6 Predicted transition probabilities transitions states 1 6 se1, se2, se3, se4, se5, se6 Standard error predicted transition probabilities transitions states 1 6","code":""},{"path":"https://alexpate30.github.io/calibmsm/reference/tp_cmprsk_j0.html","id":"source","dir":"Reference","previous_headings":"","what":"Source","title":"Predicted risks for a competing risks model out of state j = 0 ‚Äî tp_cmprsk_j0","text":"dataset derived data made available within mstate package, see ebmt4. data originally provided European Group Blood Marrow Transplantation (https://www.ebmt.org/). reiterate source statement given developers mstate: \"acknowledge European Society Blood Marrow Transplantation (EBMT) making available data. Disclaimer: data simplified purpose illustration analysis competing risks multi-state models reflect real life situation. clinical conclusions drawn data.\"","code":""},{"path":"https://alexpate30.github.io/calibmsm/reference/tp_cmprsk_j0.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Predicted risks for a competing risks model out of state j = 0 ‚Äî tp_cmprsk_j0","text":"Data frame containing predicted transition probabilities state j = 1 made time s = 0, competing risks model initial state (see msebmtcal_cmprsk). predicted transition probabilities estimated fitting competing risks model msebmtcal_cmprsk data using leave-one-approach. Code deriving dataset provided source code calibmsm. Code derivation dataset provided source code package.","code":""},{"path":"https://alexpate30.github.io/calibmsm/reference/tp_cmprsk_j0.html","id":"references","dir":"Reference","previous_headings":"","what":"References","title":"Predicted risks for a competing risks model out of state j = 0 ‚Äî tp_cmprsk_j0","text":"EBMT (2023). ‚ÄúData European Society Blood Marrow Transplantation.‚Äù URL https://search.r-project.org/CRAN/refmans/mstate/html/EBMT-data.html. de Wreede LC, Fiocco M, Putter H (2011). ‚Äúmstate: R Package Analysis Competing Risks Multi-State Models.‚Äù Journal Statistical Software, 38(7).","code":""},{"path":"https://alexpate30.github.io/calibmsm/reference/tps0.html","id":null,"dir":"Reference","previous_headings":"","what":"Predicted transition probabilities out of transplant state made at time s = 0 ‚Äî tps0","title":"Predicted transition probabilities out of transplant state made at time s = 0 ‚Äî tps0","text":"Data frame containing predicted transition probabilities state j = 1 made time s = 0. predicted transition probabilities estimated fitting multistate model ebmt4 data using leave-one-approach. Code deriving dataset provided source code calibmsm. Code derivation dataset provided source code package.","code":""},{"path":"https://alexpate30.github.io/calibmsm/reference/tps0.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Predicted transition probabilities out of transplant state made at time s = 0 ‚Äî tps0","text":"","code":"tps0"},{"path":[]},{"path":"https://alexpate30.github.io/calibmsm/reference/tps0.html","id":"-tps-","dir":"Reference","previous_headings":"","what":"'tps0'","title":"Predicted transition probabilities out of transplant state made at time s = 0 ‚Äî tps0","text":"data frame 13,674 (CHANGE) rows 14 columns: id Patient indentifier pstate1, pstate2, pstate3, pstate4, pstate5, pstate6 Predicted transition probabilities transitions states 1 6 se1, se2, se3, se4, se5, se6 Standard error predicted transition probabilities transitions states 1 6 j State predicted transition probabilities estimated ","code":""},{"path":"https://alexpate30.github.io/calibmsm/reference/tps0.html","id":"source","dir":"Reference","previous_headings":"","what":"Source","title":"Predicted transition probabilities out of transplant state made at time s = 0 ‚Äî tps0","text":"dataset derived data made available within mstate package, see ebmt4. data originally provided European Group Blood Marrow Transplantation (https://www.ebmt.org/). reiterate source statement given developers mstate: \"acknowledge European Society Blood Marrow Transplantation (EBMT) making available data. Disclaimer: data simplified purpose illustration analysis competing risks multi-state models reflect real life situation. clinical conclusions drawn data.\"","code":""},{"path":"https://alexpate30.github.io/calibmsm/reference/tps0.html","id":"references","dir":"Reference","previous_headings":"","what":"References","title":"Predicted transition probabilities out of transplant state made at time s = 0 ‚Äî tps0","text":"EBMT (2023). ‚ÄúData European Society Blood Marrow Transplantation.‚Äù URL https://search.r-project.org/CRAN/refmans/mstate/html/EBMT-data.html. de Wreede LC, Fiocco M, Putter H (2011). ‚Äúmstate: R Package Analysis Competing Risks Multi-State Models.‚Äù Journal Statistical Software, 38(7).","code":""},{"path":"https://alexpate30.github.io/calibmsm/reference/tps100.html","id":null,"dir":"Reference","previous_headings":"","what":"Predicted transition probabilities out of every state made at time s = 100 ‚Äî tps100","title":"Predicted transition probabilities out of every state made at time s = 100 ‚Äî tps100","text":"Data frame containing predicted transition probabilities states 1 (transplant), 2 (adverse event), 3 (recovery) 4 (adverse event + recovery), made time s = 100. predicted transition probabilities estimated fitting multistate model ebmt4 data using leave-one-approach. Code deriving dataset provided source code calibmsm. Code derivation dataset provided source code package.","code":""},{"path":"https://alexpate30.github.io/calibmsm/reference/tps100.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Predicted transition probabilities out of every state made at time s = 100 ‚Äî tps100","text":"","code":"tps100"},{"path":[]},{"path":"https://alexpate30.github.io/calibmsm/reference/tps100.html","id":"-tps-","dir":"Reference","previous_headings":"","what":"'tps100'","title":"Predicted transition probabilities out of every state made at time s = 100 ‚Äî tps100","text":"data frame 13,674 (CHANGE) rows 14 columns: id Patient indentifier pstate1, pstate2, pstate3, pstate4, pstate5, pstate6 Predicted transition probabilities transitions states 1 6 se1, se2, se3, se4, se5, se6 Standard error predicted transition probabilities transitions states 1 6 j State predicted transition probabilities estimated ","code":""},{"path":"https://alexpate30.github.io/calibmsm/reference/tps100.html","id":"source","dir":"Reference","previous_headings":"","what":"Source","title":"Predicted transition probabilities out of every state made at time s = 100 ‚Äî tps100","text":"dataset derived data made available within mstate package, see ebmt4. data originally provided European Group Blood Marrow Transplantation (https://www.ebmt.org/). reiterate source statement given developers mstate: \"acknowledge European Society Blood Marrow Transplantation (EBMT) making available data. Disclaimer: data simplified purpose illustration analysis competing risks multi-state models reflect real life situation. clinical conclusions drawn data.\"","code":""},{"path":"https://alexpate30.github.io/calibmsm/reference/tps100.html","id":"references","dir":"Reference","previous_headings":"","what":"References","title":"Predicted transition probabilities out of every state made at time s = 100 ‚Äî tps100","text":"EBMT (2023). ‚ÄúData European Society Blood Marrow Transplantation.‚Äù URL https://search.r-project.org/CRAN/refmans/mstate/html/EBMT-data.html. de Wreede LC, Fiocco M, Putter H (2011). ‚Äúmstate: R Package Analysis Competing Risks Multi-State Models.‚Äù Journal Statistical Software, 38(7).","code":""},{"path":"https://alexpate30.github.io/calibmsm/news/index.html","id":"calibmsm-111","dir":"Changelog","previous_headings":"","what":"calibmsm 1.1.1","title":"calibmsm 1.1.1","text":"CRAN release: 2024-06-14 Minor update introducing new S3 generic metadata, updated S3 methods producing errors.","code":""},{"path":"https://alexpate30.github.io/calibmsm/news/index.html","id":"calibmsm-110","dir":"Changelog","previous_headings":"","what":"calibmsm 1.1.0","title":"calibmsm 1.1.0","text":"CRAN release: 2024-05-13 Change package structure. Introduced one master function calibmsm assess calibration using BLR-IPCW, MLR-IPCW pseudo-values methodology. calib_blr changed calib_blr_ipcw, calib_mlr changed calib_mlr_ipcw, calib_blr_ipcw, calib_mlr_ipcw calib_pv changed internal functions. Return pseudo-values used estimate calibration curves output calib_pv, allows users parallelise code estimating pseudo-values. minor changes code internal functions, introduction new internal functions processes occur number times within package (example application landmarking).","code":""},{"path":"https://alexpate30.github.io/calibmsm/news/index.html","id":"calibmsm-100","dir":"Changelog","previous_headings":"","what":"calibmsm 1.0.0","title":"calibmsm 1.0.0","text":"CRAN release: 2023-11-30 Submission first version package CRAN.","code":""},{"path":"https://alexpate30.github.io/calibmsm/news/index.html","id":"calibmsm-0009000","dir":"Changelog","previous_headings":"","what":"calibmsm 0.0.0.9000","title":"calibmsm 0.0.0.9000","text":"Added NEWS.md file track changes package.","code":""}]
