[{"path":"https://alexpate30.github.io/calibmsm/LICENSE.html","id":null,"dir":"","previous_headings":"","what":"MIT License","title":"MIT License","text":"Copyright (c) 2023 calibmsm authors Permission hereby granted, free charge, person obtaining copy software associated documentation files (“Software”), deal Software without restriction, including without limitation rights use, copy, modify, merge, publish, distribute, sublicense, /sell copies Software, permit persons Software furnished , subject following conditions: copyright notice permission notice shall included copies substantial portions Software. SOFTWARE PROVIDED “”, WITHOUT WARRANTY KIND, EXPRESS IMPLIED, INCLUDING LIMITED WARRANTIES MERCHANTABILITY, FITNESS PARTICULAR PURPOSE NONINFRINGEMENT. EVENT SHALL AUTHORS COPYRIGHT HOLDERS LIABLE CLAIM, DAMAGES LIABILITY, WHETHER ACTION CONTRACT, TORT OTHERWISE, ARISING , CONNECTION SOFTWARE USE DEALINGS SOFTWARE.","code":""},{"path":"https://alexpate30.github.io/calibmsm/articles/BLR-IPCW-manual-bootstrap-with-custom-function-for-estimating-the-weights.html","id":"data-preperation","dir":"Articles","previous_headings":"","what":"Data preperation","title":"BLR-IPCW-manual-bootstrap-with-custom-function-for-estimating-the-weights","text":"vignette compares showcases manually apply bootstrap procedure estimate confidence interval BLR-IPCW calibration curve using custom function estimtae inverse probability censoring weights. start reminding EBMT EBMT (2023) validation datasets ebmtcal msebmtcal, predicted transition probabilities multistate model state j = 1 made time s = 0 (tps0). also set time want evaluate transition probabilities t.eval. Please refer vignette overview detailed description data.","code":"set.seed(101)  library(calibmsm)  data(\"ebmtcal\") head(ebmtcal) #>   id  rec rec.s   ae ae.s recae recae.s  rel rel.s  srv srv.s      year agecl #> 1  1   22     1  995    0   995       0  995     0  995     0 1995-1998 20-40 #> 2  2   29     1   12    1    29       1  422     1  579     1 1995-1998 20-40 #> 3  3 1264     0   27    1  1264       0 1264     0 1264     0 1995-1998 20-40 #> 4  4   50     1   42    1    50       1   84     1  117     1 1995-1998 20-40 #> 5  5   22     1 1133    0  1133       0  114     1 1133     0 1995-1998   >40 #> 6  6   33     1   27    1    33       1 1427     0 1427     0 1995-1998 20-40 #>   proph              match dtcens dtcens.s #> 1    no no gender mismatch    995        1 #> 2    no no gender mismatch    422        0 #> 3    no no gender mismatch   1264        1 #> 4    no    gender mismatch     84        0 #> 5    no    gender mismatch    114        0 #> 6    no no gender mismatch   1427        1  data(\"msebmtcal\") head(msebmtcal) #>   id from to trans Tstart Tstop time status #> 1  1    1  2     1      0    22   22      1 #> 2  1    1  3     2      0    22   22      0 #> 3  1    1  5     3      0    22   22      0 #> 4  1    1  6     4      0    22   22      0 #> 5  1    2  4     5     22   995  973      0 #> 6  1    2  5     6     22   995  973      0  data(\"tps0\") head(tps0) #>   id   pstate1   pstate2    pstate3   pstate4   pstate5   pstate6        se1 #> 1  1 0.1139726 0.2295006 0.08450376 0.2326861 0.1504855 0.1888514 0.01291133 #> 2  2 0.1140189 0.2316569 0.08442692 0.2328398 0.1481977 0.1888598 0.01291552 #> 3  3 0.1136646 0.2317636 0.08274331 0.2325663 0.1504787 0.1887834 0.01289444 #> 4  4 0.1383878 0.1836189 0.07579429 0.2179331 0.1538475 0.2304185 0.01857439 #> 5  5 0.1233226 0.1609740 0.05508100 0.1828176 0.1425950 0.3352099 0.01944967 #> 6  6 0.1136646 0.2317636 0.08462424 0.2305854 0.1505534 0.1888087 0.01289444 #>          se2        se3        se4        se5        se6 j #> 1 0.02369584 0.01257251 0.02323376 0.01648630 0.01601795 1 #> 2 0.02374329 0.01256056 0.02324869 0.01632797 0.01603703 1 #> 3 0.02375770 0.01245752 0.02322375 0.01647890 0.01601525 1 #> 4 0.03004447 0.01462570 0.03018673 0.02124071 0.02416121 1 #> 5 0.03419721 0.01367768 0.03423941 0.02329644 0.03688586 1 #> 6 0.02375770 0.01257276 0.02317348 0.01649531 0.01602438 1  t.eval <- 1826"},{"path":"https://alexpate30.github.io/calibmsm/articles/BLR-IPCW-manual-bootstrap-with-custom-function-for-estimating-the-weights.html","id":"confidence-intervals-for-blr-ipcw-using-internal-bootstrapping-procedure","dir":"Articles","previous_headings":"","what":"Confidence intervals for BLR-IPCW using internal bootstrapping procedure","title":"BLR-IPCW-manual-bootstrap-with-custom-function-for-estimating-the-weights","text":"now remind procedure generating confidence interval, estimate confidence interval BLR-IPCW calibration curve using internal bootstrapping procedure, done vignette overview. Resample validation dataset replacement Landmark dataset assessment calibration Calculate inverse probability censoring weights Fit preferred calibration model landmarked dataset (restricted cubic splines loess smoother) Generate observed event probabilities fixed vector predicted transition probabilities (specifically predicted transition probabilities non-bootstrapped landmark validation dataset) code produce confidence interval follows: Figure 2: Calibration plots using BLR-IPCW, confidence interval estimated using manual bootstrap procedure","code":"dat.calib.blr <-   calib_blr(data.mstate = msebmtcal,                  data.raw = ebmtcal,                  j=1,                  s=0,                  t.eval = t.eval,                  tp.pred = tps0 |>                   dplyr::filter(j == 1) |>                   dplyr::select(any_of(paste(\"pstate\", 1:6, sep = \"\"))),                  curve.type = \"rcs\",                  rcs.nk = 3,                  w.covs = c(\"year\", \"agecl\", \"proph\", \"match\"),                  CI = 95,                  CI.R.boot = 200) plot(dat.calib.blr, combine = TRUE)"},{"path":"https://alexpate30.github.io/calibmsm/articles/BLR-IPCW-manual-bootstrap-with-custom-function-for-estimating-the-weights.html","id":"confidence-intervals-for-blr-ipcw-by-inputting-custom-weights-funciton-into-calib_blr","dir":"Articles","previous_headings":"","what":"Confidence intervals for BLR-IPCW by inputting custom weights funciton into calib_blr","title":"BLR-IPCW-manual-bootstrap-with-custom-function-for-estimating-the-weights","text":"approach accessible, may lead misspecified model weights given user control choice model (Cox model) functional form predictor variables \\(\\textbf{Z}\\), continuous variables assumed linear effects hazard, interaction terms. encourage users explore data produce suitable model estimate weights. Please see vignette overview definition weights estimate . internal bootstrapping procedure can utilised function estimating weights, specified w.function argument. function must parameters function internal procedure calc_weights, even plan use parameters. parameters called arguments w. prefix calib_blr. Specification extra parameters calc_weights also allowed. parameters called ... argument calc_clib_blr. showcase defining new function calc_weights_manual. example, specify calc_weights, function used estimate weights internal procedure, aim vignette exemplify use package. practice, reason option user specify function estimating weights. Given choice function estimate weights, calibration curve Figure 1, confidence interval similar size. Figure 2: Calibration plots using BLR-IPCW, confidence interval estimated using internal bootstrap procedure custom specification function estimate weights","code":"calc_weights_manual <- calibmsm::calc_weights  dat.calib.blr.w.function <-   calib_blr(data.mstate = msebmtcal,                  data.raw = ebmtcal,                  j=1,                  s=0,                  t.eval = t.eval,                  tp.pred = tps0 |>                   dplyr::filter(j == 1) |>                   dplyr::select(any_of(paste(\"pstate\", 1:6, sep = \"\"))),                  curve.type = \"rcs\",                  rcs.nk = 3,                  w.function = calc_weights_manual,                  w.covs = c(\"year\", \"agecl\", \"proph\", \"match\"),                  CI = 95,                  CI.R.boot = 200) plot(dat.calib.blr.w.function, combine = TRUE, nrow = 2, ncol = 3)"},{"path":"https://alexpate30.github.io/calibmsm/articles/BLR-IPCW-manual-bootstrap-with-custom-function-for-estimating-the-weights.html","id":"confidence-intervals-for-blr-ipcw-by-manually-running-bootstrapping-procedure-with-custom-function-for-estimating-the-weights","dir":"Articles","previous_headings":"","what":"Confidence intervals for BLR-IPCW by manually running bootstrapping procedure with custom function for estimating the weights","title":"BLR-IPCW-manual-bootstrap-with-custom-function-for-estimating-the-weights","text":"Finally, showcase run bootstrapping procedure manually. allow users specify functions estimate weights arguments differ calc_weights, also allow users parallelise code reduce computational runtime. done using package boot(Canty Ripley 2022) conjunction calib_blr. start creating permanent object predicted risks individual. validation cohort code resampled, appropriate predicted transition probabilities must also resampled object. Next define predicted transition probabilities observed event probabilities plotted, must every bootstrapped calibration curve. predicted transition probabilities individuals uncensored time t.eval, predicted transition probabilities original calibration curves. calibration curves (confidence interval) now calculated. utilise calc_weights function calibmsm estimate weights, function used internally. However, practice point exercise create better performing model estimate weights one internal procedure. vector weights entry every row validation dataset. individuals included landmark cohort, censored prior time \\(t\\), weights can take value included calibration model fitted. observed event probabilities can estimated using calib_blr call weights argument. now time estimate confidence interval curve. define function calc_obs_boot generate bootstrapped calibration curve compatible boot function boot package. Within bootstrapped dataset, weights calculated calibration curve estimated using calib_blr. use argument data.pred.plot calib_blr essential , ensure bootstrapped observed event probabilities generated vectors predicted transition probabilities. function also written estimate curve transition probabilities specific state \\(k\\), output boot must vector, rather matrix. done utilising transitions.argument calib_blr. size confidence interval, states \\(k\\) individuals may transition state \\(j\\), list store data plots defined: bootstrap procedure now applied validation dataset ebmtcal state \\(k\\) valid.transitions, upper lower confidence bands stored data.frame along calibration curve calculated earlier. Finally, metadata added appropriate class defined data format output calib_blr, meaning can used S3 generic plot. Note example assessed.transitions = valid.transitions, may case estimated calibration curves subset possible transitions. calibration curves manually estimated confidence intervals plotted Figure 3. Figure similar Figures 1 2. expected given used model estimate weights used internal procedure, verifies manual procedure calculating confidence interval successful. Figure 3: Calibration plots using BLR-IPCW, confidence interval estimated using manual bootstrap procedure","code":"tp.pred <- tps0 |>   dplyr::filter(j == 1) |>   dplyr::select(any_of(paste(\"pstate\", 1:6, sep = \"\"))) ## Extract ids for individuals uncensored at t.eval ids.uncens <- ebmtcal |>   subset(dtcens > t.eval | (dtcens < t.eval & dtcens.s == 0)) |>   dplyr::pull(id) ## Extract the predicted risks out of state 1 for these individuals data.pred.plot <- tps0 |>   dplyr::filter(j == 1 & id %in% ids.uncens) |>   dplyr::select(any_of(paste(\"pstate\", 1:6, sep = \"\"))) weights.manual <-   calc_weights(data.mstate = msebmtcal,                data.raw = ebmtcal,                covs = c(\"year\", \"agecl\", \"proph\", \"match\"),                t.eval = t.eval,                s = 0,                landmark.type = \"state\",                j = 1,                max.weight = 10,                stabilised = FALSE)$ipcw str(weights.manual) #>  num [1:2279] NA 1.14 NA 1.01 1.03 ... dat.calib.boot.manual <-   calib_blr(data.mstate = msebmtcal,                  data.raw = ebmtcal,                  j=1,                  s=0,                  t.eval = t.eval,                  tp.pred = tp.pred,                  curve.type = \"rcs\",                  rcs.nk = 3,                  weights = weights.manual) calc_obs_boot <- function(data, indices, tp.pred, state.k){    ## Bootstrap dataset and predicted transition probabilities   data.boot <- data[indices,]   tp.pred.boot <- tp.pred[indices, ]    ## Calculate weights   ## In practice - replace this function with your own   weights.manual <-     calc_weights(data.mstate = msebmtcal,                  data.raw = data.boot,                  covs = c(\"year\", \"agecl\", \"proph\", \"match\"),                  t.eval = t.eval,                  s = 0,                  landmark.type = \"state\",                  j = 1,                  max.weight = 10,                  stabilised = FALSE)$ipcw    ## Estimate bootstrapped calibration curve   curve.est <-     calib_blr(data.mstate = msebmtcal,                    data.raw = data.boot,                    j=1,                    s=0,                    t.eval = t.eval,                    tp.pred = tp.pred.boot,                    curve.type = \"rcs\",                    rcs.nk = 3,                    weights = weights.manual,                    data.pred.plot = data.pred.plot,                    transitions.out = state.k)    ## Extract observed event probabilities   curve.obs <-     curve.est[[\"plotdata\"]][[paste(\"state\", state.k, sep = \"\")]]$obs    return(curve.obs)  } alpha <- (1-95/100)/2 valid.transitions <- which(colSums(tp.pred) != 0) plot.data.list <- vector(\"list\", length(valid.transitions)) for (k in 1:length(valid.transitions)){    ## Assign state k   state.k <- valid.transitions[k]    ## Run bootstrapping   boot.obs <- boot::boot(ebmtcal,                          calc_obs_boot,                          R = 200,                          tp.pred = tp.pred,                          state.k = state.k)$t    ## Extract confidence bands   lower <- apply(boot.obs, 2, stats::quantile, probs = alpha, na.rm = TRUE)   upper <- apply(boot.obs, 2, stats::quantile, probs = 1-alpha, na.rm = TRUE)    ## Assign output   plot.data.list[[k]] <- data.frame(     \"pred\" = dat.calib.boot.manual[[\"plotdata\"]][[k]]$pred,     \"obs\" = dat.calib.boot.manual[[\"plotdata\"]][[k]]$obs,     \"obs.lower\" = lower,     \"obs.upper\" = upper)  } metadata <- list(\"valid.transitions\"= valid.transitions,                  \"assessed.transitions\" = valid.transitions,                  \"CI\" = 95,                  \"curve.type\" = \"rcs\") dat.calib.blr.manual <- list(\"plotdata\" = plot.data.list, \"metadata\" = metadata) attr(dat.calib.blr.manual, \"class\") <- \"calib_blr\" plot(dat.calib.blr.manual)"},{"path":"https://alexpate30.github.io/calibmsm/articles/Comparison-with-graphical-calibration-curves-in-competing-risks-setting.html","id":"data-preperation","dir":"Articles","previous_headings":"","what":"Data preperation","title":"Comparison-with-graphical-calibration-curves-in-competing-risks-setting","text":"vignette compares calibration competing risks model using approaches provided calibmsm, namely BLR-IPCW pseudo-value approaches, graphical calibration curves developed Austin et al. (2022). use data European Society Blood Marrow Transplantation (EBMT 2023), contains multistate survival data transplant patients blood cancer. start follow day transplant initial state alive remission. three intermediate events (\\(2\\): recovery, \\(3\\): adverse event, \\(4\\): recovery + adverse event), two absorbing states (\\(5\\): relapse \\(6\\): death). data originally made available mstate package (Wreede, Fiocco, Putter 2011). example, treat transitions first state standalone competing risks model setting subsequent states absorbing states. ignoring subsequent multistate aspect data. first load predicted transition probabilities individual model, provided dataset tp.cmprsk.j0. code deriving available source code package (see prepare_vignette_cmprsk_data.R). generated specifying transition matrix define competing risks model (.e. subsequent states act absorbing states), generate predicted risks (cumulative incidence functions) using theory Putter, Fiocco, Geskus (2007). derived using software mstate (Wreede, Fiocco, Putter 2011). Predicted risks generated individual using leave-one-approach (.e. individual removed dataset, fitting competing risks model generating predicted risks). following four variables used esimate predicted risks: year transplant (year), age transplant (age), prophylaxis given (proph), whether donor gender matched (match). transition probabilities stored object tp.cmprsk.j0. Datasets formats required functions calib_blr calib_pv stored ebmtcal (data.raw argument) msebmtcal.cmprsk (data.mstate argument). Note ebmtcal dataset can still used argument data.raw, new dataset data.mstate argument required, reflects fact now competing risks data structure. Please refer vignette details datasets formatted. assess calibration 5 years (1826 days) methods.","code":"library(calibmsm)  data(\"tp.cmprsk.j0\") head(tp.cmprsk.j0) #>   id   pstate1   pstate2   pstate3 pstate4    pstate5    pstate6        se1 #> 1  1 0.1135057 0.4093590 0.3964498       0 0.02688596 0.05379955 0.01291270 #> 2  2 0.1135518 0.4114981 0.3942408       0 0.02689840 0.05381085 0.01291690 #> 3  3 0.1131989 0.4117482 0.3944988       0 0.02681945 0.05373457 0.01289565 #> 4  4 0.1376981 0.3870386 0.3728509       0 0.04027730 0.06213511 0.01858789 #> 5  5 0.1227877 0.4277392 0.3496972       0 0.03130458 0.06847131 0.01945048 #> 6  6 0.1131989 0.4117482 0.3944988       0 0.02681945 0.05373457 0.01289565 #>          se2        se3 se4         se5         se6 #> 1 0.01918215 0.01874680   0 0.006339773 0.007719292 #> 2 0.01920148 0.01870398   0 0.006342388 0.007719937 #> 3 0.01921355 0.01871733   0 0.006325238 0.007708340 #> 4 0.02447306 0.02323096   0 0.010698591 0.010818696 #> 5 0.02777129 0.02476595   0 0.009947925 0.012554747 #> 6 0.01921355 0.01871733   0 0.006325238 0.007708340  data(\"ebmtcal\") head(ebmtcal) #>   id  rec rec.s   ae ae.s recae recae.s  rel rel.s  srv srv.s      year agecl #> 1  1   22     1  995    0   995       0  995     0  995     0 1995-1998 20-40 #> 2  2   29     1   12    1    29       1  422     1  579     1 1995-1998 20-40 #> 3  3 1264     0   27    1  1264       0 1264     0 1264     0 1995-1998 20-40 #> 4  4   50     1   42    1    50       1   84     1  117     1 1995-1998 20-40 #> 5  5   22     1 1133    0  1133       0  114     1 1133     0 1995-1998   >40 #> 6  6   33     1   27    1    33       1 1427     0 1427     0 1995-1998 20-40 #>   proph              match dtcens dtcens.s #> 1    no no gender mismatch    995        1 #> 2    no no gender mismatch    422        0 #> 3    no no gender mismatch   1264        1 #> 4    no    gender mismatch     84        0 #> 5    no    gender mismatch    114        0 #> 6    no no gender mismatch   1427        1  data(\"msebmtcal.cmprsk\") head(msebmtcal.cmprsk) #>   id from to trans Tstart Tstop time status #> 1  1    1  2     1      0    22   22      1 #> 2  1    1  3     2      0    22   22      0 #> 3  1    1  5     3      0    22   22      0 #> 4  1    1  6     4      0    22   22      0 #> 5  2    1  2     1      0    12   12      0 #> 6  2    1  3     2      0    12   12      1"},{"path":"https://alexpate30.github.io/calibmsm/articles/Comparison-with-graphical-calibration-curves-in-competing-risks-setting.html","id":"assess-calibration-using-blr-ipcw","dir":"Articles","previous_headings":"","what":"Assess calibration using BLR-IPCW","title":"Comparison-with-graphical-calibration-curves-in-competing-risks-setting","text":"first assess calibration competing risks model using BLR-IPCW approach, implemented calib_blr. Figure 1: Calibration plots competing risks model starting state using BLR-IPCW","code":"### Estimate calibration curves dat.calib.blr <-   calib_blr(data.mstate = msebmtcal.cmprsk,                  data.raw = ebmtcal,                  j=1,                  s=0,                  t.eval = 1826,                  tp.pred = tp.cmprsk.j0 |>                    dplyr::select(any_of(paste(\"pstate\", 1:6, sep = \"\"))),                  curve.type = \"rcs\",                  rcs.nk = 3,                  w.covs = c(\"year\", \"agecl\", \"proph\", \"match\"),                  CI = 95,                  CI.R.boot = 20)  ### Turn into plot and print plot.calibmsm.blr <- plot(dat.calib.blr, combine = TRUE, nrow = 2, ncol = 3) plot.calibmsm.blr"},{"path":"https://alexpate30.github.io/calibmsm/articles/Comparison-with-graphical-calibration-curves-in-competing-risks-setting.html","id":"assess-calibration-using-pseudo-values","dir":"Articles","previous_headings":"","what":"Assess calibration using pseudo-values","title":"Comparison-with-graphical-calibration-curves-in-competing-risks-setting","text":"Next assess calibration competing risks model using pseudo-value approach, implemented calib_pv. Figure 2: Calibration plots competing risks model starting state using pseudo-values","code":"### Estimate calibration curves dat.calib.pv <-   calib_pv(data.mstate = msebmtcal.cmprsk,                  data.raw = ebmtcal,                  j=1,                  s=0,                  t.eval = 1826,                  tp.pred = tp.cmprsk.j0 |>                    dplyr::select(any_of(paste(\"pstate\", 1:6, sep = \"\"))),                  curve.type = \"rcs\",                  rcs.nk = 3,                  n.pctls = 9,                  CI = 95,                  CI.type = \"parametric\") #> [1] \"Calculate pseudo values for state =  1 2023-06-13 17:09:02.926836\" #> [1] \"Calculate pseudo values for state =  2 2023-06-13 17:13:01.061347\" #> [1] \"Calculate pseudo values for state =  3 2023-06-13 17:16:58.828961\" #> [1] \"Calculate pseudo values for state =  5 2023-06-13 17:20:57.585022\" #> [1] \"Calculate pseudo values for state =  6 2023-06-13 17:24:42.879905\"  ### Turn into plot and print plot.calibmsm.pv <- plot(dat.calib.pv, combine = TRUE, nrow = 2, ncol = 3) plot.calibmsm.pv"},{"path":"https://alexpate30.github.io/calibmsm/articles/Comparison-with-graphical-calibration-curves-in-competing-risks-setting.html","id":"assess-calibration-using-graphical-calibration-curves","dir":"Articles","previous_headings":"","what":"Assess calibration using graphical calibration curves","title":"Comparison-with-graphical-calibration-curves-in-competing-risks-setting","text":"Finally assess calibration competing risks model using graphical calibration curves approach Austin et al. (2022). custom function written , estimates calibration curves returns list plots using ggplot2. function applied estimate calibration curves create plots. Figure 3: Calibration plots competing risks model starting state using graphical calibration curves","code":"### Estimate calibration curves and create plots plot.gcc.rcs.list <- calc.calib.gcc.mod(data.mstate = msebmtcal.cmprsk,                                     data.raw = ebmtcal,                                     j = 1,                                     s = 0,                                     t.eval = 1826,                                     p.est = tp.cmprsk.j0[,paste(\"pstate\", 1:6, sep = \"\")],                                     nk = 3)  ### Combine into one plot and print plot.gcc.rcs <- ggpubr::ggarrange(plotlist = plot.gcc.rcs.list) plot.gcc.rcs"},{"path":"https://alexpate30.github.io/calibmsm/articles/Comparison-with-graphical-calibration-curves-in-competing-risks-setting.html","id":"comarpsion-of-results","dir":"Articles","previous_headings":"","what":"Comarpsion of results","title":"Comparison-with-graphical-calibration-curves-in-competing-risks-setting","text":"Note graphical calibration curves approach provide way assess calibration state 1. calibration transition probabilities states similar irrespecive method used assess calibration. exception calibration transition probabilities state 3 using BLR-IPCW approach. Possible reasons discussed vignette .","code":""},{"path":"https://alexpate30.github.io/calibmsm/authors.html","id":null,"dir":"","previous_headings":"","what":"Authors","title":"Authors and Citation","text":"Alexander Pate. Author, maintainer.","code":""},{"path":"https://alexpate30.github.io/calibmsm/authors.html","id":"citation","dir":"","previous_headings":"","what":"Citation","title":"Authors and Citation","text":"Pate (2023). calibmsm: Calibration plots transition probabilities multistate models. R package version 0.0.0.9000, https://alexpate30.github.io/calibmsm/.","code":"@Manual{,   title = {calibmsm: Calibration plots for the transition probabilities from multistate models},   author = {Alexander Pate},   year = {2023},   note = {R package version 0.0.0.9000},   url = {https://alexpate30.github.io/calibmsm/}, }"},{"path":"https://alexpate30.github.io/calibmsm/index.html","id":"calibmsm","dir":"","previous_headings":"","what":"Calibration plots for the transition probabilities from multistate models","title":"Calibration plots for the transition probabilities from multistate models","text":"goal calibmsm provide set tools producing calibration plots validating existing (.e. previously developed) multistate model.","code":""},{"path":"https://alexpate30.github.io/calibmsm/index.html","id":"installation","dir":"","previous_headings":"","what":"Installation","title":"Calibration plots for the transition probabilities from multistate models","text":"can install development version calibmsm GitHub :","code":"# install.packages(\"devtools\") devtools::install_github(\"alexpate30/calibmsm\")"},{"path":"https://alexpate30.github.io/calibmsm/index.html","id":"example","dir":"","previous_headings":"","what":"Example","title":"Calibration plots for the transition probabilities from multistate models","text":"basic example shows assess calibration transition probabilities 5 years follow individuals state j time s. predicted transition probabilities stored tps0, individuals data stored ebmtcal, data msdata format stored msebmtcal. Calibration curves estimated using calc_calib_blr. Inverse probability censoring weights calculated based variables year, age, prophylaxis donor gender match. calibration curves estimated using restricted cubic splines. 95% confidence interval calculated using bootstrapping 200 bootstrap replicates.  Calibration scatter plots can also estimated using calc_calib_mlr.","code":"## Load calibmsm library(calibmsm)  ## Extract relevant predicted risks from tps0 tp.pred <- dplyr::select(dplyr::filter(tps0, j == 1), any_of(paste(\"pstate\", 1:6, sep = \"\")))  ## Calculate observed event probabilities dat.calib.blr <-   calc_calib_blr(data.mstate = msebmtcal,                  data.raw = ebmtcal,                  j=1,                  s=0,                  t.eval = 1826,                  tp.pred = tp.pred,                  curve.type = \"rcs\",                  rcs.nk = 3,                  w.covs = c(\"year\", \"agecl\", \"proph\", \"match\"),                  CI = 95,                  CI.R.boot = 200)  ## Produce summary summary(dat.calib.blr) #> There were non-zero predicted transition probabilities into states  1,2,3,4,5,6 #>  #> Calibration curves have been estimated for transitions into states  1,2,3,4,5,6 #>  #> Calibration was assessed at time 1826 and calibration was assessed in a landmarked cohort of individuals in state j = 1 at time s = 0 #>  #> A 95% confidence interval was estimated withb200 bootstrap replicates #>  #> The estimated calibration curves are stored in list element `plotdata`: #>  #> $state1 #>    id       pred       obs  obs.lower obs.upper #> 2   2 0.11401890 0.1095897 0.08523354 0.1377938 #> 4   4 0.13838778 0.1036308 0.08431507 0.1305613 #> 5   5 0.12332255 0.1051035 0.08515655 0.1283241 #> 7   7 0.09737975 0.1236322 0.08395369 0.1640331 #> 10 10 0.11371889 0.1097779 0.08511766 0.1382789 #> 13 13 0.11385388 0.1096929 0.08516975 0.1380599 #>  #> $state2 #>    id      pred       obs obs.lower obs.upper #> 2   2 0.2316569 0.1698031 0.1243572 0.2225723 #> 4   4 0.1836189 0.1855591 0.1507925 0.2188455 #> 5   5 0.1609740 0.1759804 0.1391210 0.2102321 #> 7   7 0.2121470 0.1785688 0.1447495 0.2122745 #> 10 10 0.2315632 0.1698443 0.1245111 0.2224791 #> 13 13 0.2316571 0.1698030 0.1243568 0.2225726 #>  #> $state3 #>    id       pred        obs  obs.lower obs.upper #> 2   2 0.08442692 0.12485834 0.09431395 0.1569063 #> 4   4 0.07579429 0.11666056 0.08460027 0.1451781 #> 5   5 0.05508100 0.09189341 0.04519272 0.1367071 #> 7   7 0.06154308 0.10011560 0.05905272 0.1372340 #> 10 10 0.08440940 0.12484341 0.09430722 0.1568832 #> 13 13 0.08257284 0.12323792 0.09363889 0.1543054 #>  #> $state4 #>    id      pred       obs obs.lower obs.upper #> 2   2 0.2328398 0.2427580 0.1930546 0.2863106 #> 4   4 0.2179331 0.2243106 0.1883121 0.2584585 #> 5   5 0.1828176 0.1851051 0.1550640 0.2170441 #> 7   7 0.2206335 0.2275985 0.1914898 0.2624447 #> 10 10 0.2326989 0.2425807 0.1929586 0.2859993 #> 13 13 0.2326047 0.2424622 0.1928944 0.2857912 #>  #> $state5 #>    id      pred       obs obs.lower obs.upper #> 2   2 0.1481977 0.1909795 0.1654396 0.2182979 #> 4   4 0.1538475 0.1654523 0.1484613 0.1830273 #> 5   5 0.1425950 0.2215190 0.1829005 0.2663921 #> 7   7 0.1441960 0.2123460 0.1775459 0.2495635 #> 10 10 0.1488068 0.1879278 0.1636959 0.2139830 #> 13 13 0.1505092 0.1797461 0.1588683 0.2021889 #>  #> $state6 #>    id      pred       obs obs.lower obs.upper #> 2   2 0.1888598 0.2069354 0.1856979 0.2330498 #> 4   4 0.2304185 0.2542212 0.2292881 0.2813828 #> 5   5 0.3352099 0.3163102 0.2810037 0.3582892 #> 7   7 0.2641006 0.2800368 0.2594873 0.3064739 #> 10 10 0.1888028 0.2068586 0.1856305 0.2329424 #> 13 13 0.1888022 0.2068578 0.1856298 0.2329413  ## Plot calibration plots plot(dat.calib.blr, combine = TRUE, nrow = 2, ncol = 3) ## Calculate observed event probabilities dat.calib.mlr <-   calc_calib_mlr(data.mstate = msebmtcal,                  data.raw = ebmtcal,                  j=1,                  s=0,                  t.eval = 1826,                  tp.pred = tp.pred,                  w.covs = c(\"year\", \"agecl\", \"proph\", \"match\"))  ## Produce summary summary(dat.calib.mlr) #> There were non-zero predicted transition probabilities into states  1,2,3,4,5,6 #>  #> Calibration was assessed at time 1826 and calibration was assessed in a landmarked cohort of individuals in state j = 1 at time s = 0 #>  #> The estimated calibration scatter plots are stored in list element `plotdata`: #>  #> $state1 #>   id       pred        obs #> 1  2 0.11401890 0.09197312 #> 2  4 0.13838778 0.09765456 #> 3  5 0.12332255 0.05055278 #> 4  7 0.09737975 0.10509072 #> 5 10 0.11371889 0.09474050 #> 6 13 0.11385388 0.09760555 #>  #> $state2 #>   id      pred        obs #> 1  2 0.2316569 0.09628315 #> 2  4 0.1836189 0.16086862 #> 3  5 0.1609740 0.08120535 #> 4  7 0.2121470 0.10759914 #> 5 10 0.2315632 0.09813159 #> 6 13 0.2316571 0.10453033 #>  #> $state3 #>   id       pred        obs #> 1  2 0.08442692 0.17888790 #> 2  4 0.07579429 0.13870298 #> 3  5 0.05508100 0.07723274 #> 4  7 0.06154308 0.14719397 #> 5 10 0.08440940 0.18112318 #> 6 13 0.08257284 0.18206659 #>  #> $state4 #>   id      pred       obs #> 1  2 0.2328398 0.2170579 #> 2  4 0.2179331 0.1712690 #> 3  5 0.1828176 0.3509679 #> 4  7 0.2206335 0.1452834 #> 5 10 0.2326989 0.2114548 #> 6 13 0.2326047 0.2086145 #>  #> $state5 #>   id      pred       obs #> 1  2 0.1481977 0.1871729 #> 2  4 0.1538475 0.2017993 #> 3  5 0.1425950 0.2297903 #> 4  7 0.1441960 0.1500001 #> 5 10 0.1488068 0.1815475 #> 6 13 0.1505092 0.1686992 #>  #> $state6 #>   id      pred       obs #> 1  2 0.1888598 0.2286251 #> 2  4 0.2304185 0.2297056 #> 3  5 0.3352099 0.2102509 #> 4  7 0.2641006 0.3448326 #> 5 10 0.1888028 0.2330024 #> 6 13 0.1888022 0.2384838  ## Plot calibration plots plot(dat.calib.mlr, combine = TRUE, nrow = 2, ncol = 3)"},{"path":"https://alexpate30.github.io/calibmsm/index.html","id":"getting-help","dir":"","previous_headings":"","what":"Getting help","title":"Calibration plots for the transition probabilities from multistate models","text":"encounter bug, please file issue minimal reproducible example GitHub. NB DELETE - USEFUL NOTE NOW:: ’ll still need render README.Rmd regularly, keep README.md --date. devtools::build_readme() handy . also use GitHub Actions re-render README.Rmd every time push. example workflow can found : https://github.com/r-lib/actions/tree/v1/examples.","code":""},{"path":"https://alexpate30.github.io/calibmsm/reference/calc_aj.html","id":null,"dir":"Reference","previous_headings":"","what":"Estimate Aalen-Johansen estimator for a cohort of individuals — calc_aj","title":"Estimate Aalen-Johansen estimator for a cohort of individuals — calc_aj","text":"Estimates Aalen-Johansen estimatorfor transition probabilities cohort data.mstate. Estimatestransition probabilities time t.eval state j time 0 Aalen-Johansen estimator entire cohort (including individual person_id.eval) inputted manually (obs.aj), speed computaitonal time calculating pseudo-values multiple individuals cohort.","code":""},{"path":"https://alexpate30.github.io/calibmsm/reference/calc_aj.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Estimate Aalen-Johansen estimator for a cohort of individuals — calc_aj","text":"","code":"calc_aj(data.mstate, tmat, t.eval, j)"},{"path":"https://alexpate30.github.io/calibmsm/reference/calc_aj.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Estimate Aalen-Johansen estimator for a cohort of individuals — calc_aj","text":"data.mstate Validation data msdata format tmat Transition probability matrix t.eval Follow time calibration assessed j Landmark state predictions made","code":""},{"path":"https://alexpate30.github.io/calibmsm/reference/calc_pv_aj.html","id":null,"dir":"Reference","previous_headings":"","what":"Estimate pseudo-values for the transition probabilities based on the Aalen-Johansen estimator — calc_pv_aj","title":"Estimate pseudo-values for the transition probabilities based on the Aalen-Johansen estimator — calc_pv_aj","text":"Estimates pseudo-values individual (person_id.eval) cohort data.mstate. Calculates psuedo-values transition probabilities time t.eval state j time 0 Aalen-Johansen estimator entire cohort (including individual person_id.eval) inputted manually (obs.aj), speed computaitonal time calculating pseudo-values multiple individuals cohort.","code":""},{"path":"https://alexpate30.github.io/calibmsm/reference/calc_pv_aj.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Estimate pseudo-values for the transition probabilities based on the Aalen-Johansen estimator — calc_pv_aj","text":"","code":"calc_pv_aj(person_id.eval, data.mstate, obs.aj, tmat, n.cohort, t.eval, j)"},{"path":"https://alexpate30.github.io/calibmsm/reference/calc_pv_aj.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Estimate pseudo-values for the transition probabilities based on the Aalen-Johansen estimator — calc_pv_aj","text":"person_id.eval id individual calculate pseudo-value data.mstate Validation data msdata format obs.aj Aalen-Johansen estimator transition probabilities entire cohort (excluding person_id.eval) tmat Transition probability matrix n.cohort Size cohort (number unique entries data.mstate) t.eval Follow time calibration assessed j Landmark state predictions made","code":""},{"path":"https://alexpate30.github.io/calibmsm/reference/calc_weights.html","id":null,"dir":"Reference","previous_headings":"","what":"Calculate inverse probability of censoring weights at time t.eval. — calc_weights","title":"Calculate inverse probability of censoring weights at time t.eval. — calc_weights","text":"Estimates inverse probability censoring weights fitting cox-propotinal hazards model landmark cohort individuals. Primarily used internally, function exported allow users reproduce results vignette estimating confidence intervals using bootstrapping manually.","code":""},{"path":"https://alexpate30.github.io/calibmsm/reference/calc_weights.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Calculate inverse probability of censoring weights at time t.eval. — calc_weights","text":"","code":"calc_weights(   data.mstate,   data.raw,   covs = NULL,   t.eval,   s,   landmark.type = \"state\",   j = NULL,   max.weight = 10,   stabilised = FALSE,   max.follow = NULL )"},{"path":"https://alexpate30.github.io/calibmsm/reference/calc_weights.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Calculate inverse probability of censoring weights at time t.eval. — calc_weights","text":"data.mstate Validation data msdata format data.raw Validation data data.frame (one row per individual) covs Character vector variable names adjust calculating inverse probability censoring weights t.eval Follow time calculate weights s Landmark time predictions made landmark.type Whether weights estimated individuals uncensored time s ('') individuals uncensored state j time s ('state') j Landmark state predictions made (required landmark.type = 'state') max.weight Maximum bound weights stabilised Indicates whether weights stabilised max.follow Maximum follow model calculating inverse probability censoring weights. Reducing t.eval + 1 may aid proportional hazards assumption met model.","code":""},{"path":"https://alexpate30.github.io/calibmsm/reference/calc_weights.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Calculate inverse probability of censoring weights at time t.eval. — calc_weights","text":"dataframe three columns. id corresponds patient ids data.raw. ipcw contains inverse probability censoring weights (specifically inverse probability uncesored). pcw = 1/ipcw. stabilised = TRUE specified, fourth variable ipcw.stab returned, stabilised inverse probability censoring weights.","code":""},{"path":"https://alexpate30.github.io/calibmsm/reference/calc_weights.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Calculate inverse probability of censoring weights at time t.eval. — calc_weights","text":"Fits cox proportional hazards model individuals landmark cohort, predicting probability censored time t.eval. landmark cohort may either individuals uncensored time s, uncensored state j time s. predictors w.covs assumed linear effect hazard. Weights estimated individuals data.raw, even used analysis meet landmarking requirements. individual enters absorbing state prior t.eval, estimate probability censored time entry absorbing state, rather t.eval. Details provided (vignette OVERVIEW--THEORY-XXXX)","code":""},{"path":"https://alexpate30.github.io/calibmsm/reference/calc_weights.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Calculate inverse probability of censoring weights at time t.eval. — calc_weights","text":"","code":"# Estimate inverse probability of censoring weights for individual in cohort ebmtcal. # Specifically the probability of being uncensored at t.eval = 1826 days. # Weights are estimated using a model fitted in all individuals uncensored at time s = 0. weights.manual <- calc_weights(data.mstate = msebmtcal,   data.raw = ebmtcal,   covs = c(\"year\", \"agecl\", \"proph\", \"match\"),   t.eval = 1826,   s = 0,   landmark.type = \"state\",   j = 1)    str(weights.manual) #> 'data.frame':\t2279 obs. of  3 variables: #>  $ id  : int  1 2 3 4 5 6 7 8 9 10 ... #>  $ ipcw: num  NA 1.14 NA 1.01 1.03 ... #>  $ pcw : num  NA 0.879 NA 0.99 0.975 ..."},{"path":"https://alexpate30.github.io/calibmsm/reference/calib_blr.html","id":null,"dir":"Reference","previous_headings":"","what":"Estimate calibration curves for a multistate model using binary logistic regression calibration techniques and inverse probability of censoring weights.' — calib_blr","title":"Estimate calibration curves for a multistate model using binary logistic regression calibration techniques and inverse probability of censoring weights.' — calib_blr","text":"Creates underlying data calibration curves. calib_blr estimates observed event probabilities given set predicted transition probabilities cohort interest. done using techniques assessing calibration binary logistic regression models, combination inverse probability censoring weights landmarking.","code":""},{"path":"https://alexpate30.github.io/calibmsm/reference/calib_blr.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Estimate calibration curves for a multistate model using binary logistic regression calibration techniques and inverse probability of censoring weights.' — calib_blr","text":"","code":"calib_blr(   data.mstate,   data.raw,   j,   s,   t.eval,   tp.pred,   curve.type = \"rcs\",   rcs.nk = 3,   loess.span = 0.75,   loess.degree = 2,   weights = NULL,   w.function = NULL,   w.covs = NULL,   w.landmark.type = \"state\",   w.max = 10,   w.stabilised = FALSE,   w.max.follow = NULL,   CI = FALSE,   CI.R.boot = NULL,   data.pred.plot = NULL,   transitions.out = NULL,   ... )"},{"path":"https://alexpate30.github.io/calibmsm/reference/calib_blr.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Estimate calibration curves for a multistate model using binary logistic regression calibration techniques and inverse probability of censoring weights.' — calib_blr","text":"data.mstate Validation data msdata format data.raw Validation data data.frame (one row per individual) j Landmark state predictions made s Landmark time predictions made t.eval Follow time calibration assessed tp.pred Matrix predicted transition probabilities time t.eval, state j time s. must seperate column predicted transition probabilities every state, even predicted transition probabilities 0. curve.type Whether calibration curves estimated using restricted cubic splines ('rcs') loess smoothers ('loess') rcs.nk Number knots curves estimated using restricted cubic splines loess.span Span curves estimated using loess smoothers loess.degree Degree curves estimated. using loess smoothers weights Vector inverse probability censoring weights w.function Custom function estimating inverse probability censoring weights w.covs Character vector variable names adjust calculating inverse probability censoring weights w.landmark.type Whether weights estimated individuals uncensored time s ('') individuals uncensored state j time s ('state') w.max Maximum bound inverse probability censoring weights w.stabilised Indicates whether inverse probability censoring weights stabilised w.max.follow Maximum follow model calculating inverse probability censoring weights. Reducing t.eval + 1 may aid proportional hazards assumption met model. CI Size confidence intervals % CI.R.boot Number bootstrap replicates estimating confidence interval calibration curve data.pred.plot Data frame matrix predicted risks possible transition plot calibration curves. Must one column every possible transition. transitions.Transitions calculate calibration curves. possible transitions left NULL. ... Extra arguments passed w.function (custom function estimating weights)","code":""},{"path":"https://alexpate30.github.io/calibmsm/reference/calib_blr.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Estimate calibration curves for a multistate model using binary logistic regression calibration techniques and inverse probability of censoring weights.' — calib_blr","text":"calib_blr returns list containing two elements: plotdata metadata. plotdata element contains data calibration curves. list element containing calibration plot data transition probabilities possible states. list element contains patient ids (id) data.raw, predicted transition probabilities (pred) estimated observed event probabilities (obs). confidence interval requested, upper (obs.upper) lower (obs.lower) bounds observed event probabilities also returned. data.pred.plot defined manually, column (id) returned. metadata element contains metadata including: vector possible transitions, vector transitions calibration curves estimated , size confidence interval, method estimating calibration curve user specified information.","code":""},{"path":"https://alexpate30.github.io/calibmsm/reference/calib_blr.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Estimate calibration curves for a multistate model using binary logistic regression calibration techniques and inverse probability of censoring weights.' — calib_blr","text":"Observed event probabilities time t.eval estimated predicted transition probabilities tp.pred state j time s. calib_blr estimates calibration curves using techniques assessing calibration binary logistic regression models. choice restricted cubic splines loess smoothers estimating calibration curve can made using curve.type. Landmarking applied assess calibration individuals uncensored state j time s. Censoring dealt using inverse probability censoring weights. Two datasets cohort inidividuals must provided. Firstly data.mstate must dataset class msdata, generated using [mstate] package. dataset used apply landmarking. Secondly, data.raw must data.frame one row per individual, containing desired variables estimating weights, variables time censoring (dtcens), indicator censoring dtcens.s, (dtcens.s = 1) individual censored time dtcens, dtcens.s = 0 otherwise. individual enters absorbing state, prevents censoring happening (.e. dtcens.s = 0). Unless user specifies weights using weights, weights estimated using cox-proportional hazard model, assuming linear functional form variables defined w.covs. urge users specify model estimating weights. weights argument must vector length equal number rows data.raw. Confidence intervals calibration curves can estimated using bootstrapping. procedure uses internal method estimating weights, therefore encourage users specify bootstrapping procedure, incorporates model estimating weights. Details provided vignette XXXX. calibration curves can plotted using plot.calib_blr.","code":""},{"path":"https://alexpate30.github.io/calibmsm/reference/calib_blr.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Estimate calibration curves for a multistate model using binary logistic regression calibration techniques and inverse probability of censoring weights.' — calib_blr","text":"","code":"# Estimate calibration curves for the predicted transition # probabilities at time t.eval = 1826, when predictions were made at time # s = 0 in state j = 1. These predicted transition probabilities are stored in tps0.  # Extract the predicted transition probabilities out of state j = 1 tp.pred <- dplyr::select(dplyr::filter(tps0, j == 1), any_of(paste(\"pstate\", 1:6, sep = \"\")))  # Now estimate the observed event probabilities for each possible transition. # 95% confidence intervals are estimated using bootstrapping with 200 # bootstrap repicates. In practice we recommend using a higher number.  dat.calib.blr <- calib_blr(data.mstate = msebmtcal,  data.raw = ebmtcal,  j=1,  s=0,  t.eval = 1826,  tp.pred = tp.pred,  w.covs = c(\"year\", \"agecl\", \"proph\", \"match\"),  CI = 95,  CI.R.boot = 200)  # The data for each calibration curve are stored in the \"plotdata\" list # element. str(dat.calib.blr) #> List of 2 #>  $ plotdata:List of 6 #>   ..$ state1:'data.frame':\t1778 obs. of  5 variables: #>   .. ..$ id       : int [1:1778] 2 4 5 7 10 13 14 16 18 19 ... #>   .. ..$ pred     : num [1:1778] 0.114 0.1384 0.1233 0.0974 0.1137 ... #>   .. ..$ obs      : num [1:1778] 0.11 0.104 0.105 0.124 0.11 ... #>   .. ..$ obs.lower: num [1:1778] 0.0839 0.0815 0.0827 0.0828 0.0838 ... #>   .. ..$ obs.upper: num [1:1778] 0.128 0.128 0.124 0.161 0.129 ... #>   ..$ state2:'data.frame':\t1778 obs. of  5 variables: #>   .. ..$ id       : int [1:1778] 2 4 5 7 10 13 14 16 18 19 ... #>   .. ..$ pred     : num [1:1778] 0.232 0.184 0.161 0.212 0.232 ... #>   .. ..$ obs      : num [1:1778] 0.17 0.186 0.176 0.179 0.17 ... #>   .. ..$ obs.lower: num [1:1778] 0.124 0.158 0.146 0.148 0.125 ... #>   .. ..$ obs.upper: num [1:1778] 0.226 0.226 0.216 0.213 0.225 ... #>   ..$ state3:'data.frame':\t1778 obs. of  5 variables: #>   .. ..$ id       : int [1:1778] 2 4 5 7 10 13 14 16 18 19 ... #>   .. ..$ pred     : num [1:1778] 0.0844 0.0758 0.0551 0.0615 0.0844 ... #>   .. ..$ obs      : num [1:1778] 0.1249 0.1167 0.0919 0.1001 0.1248 ... #>   .. ..$ obs.lower: num [1:1778] 0.0973 0.0856 0.0443 0.0604 0.0973 ... #>   .. ..$ obs.upper: num [1:1778] 0.158 0.147 0.134 0.136 0.158 ... #>   ..$ state4:'data.frame':\t1778 obs. of  5 variables: #>   .. ..$ id       : int [1:1778] 2 4 5 7 10 13 14 16 18 19 ... #>   .. ..$ pred     : num [1:1778] 0.233 0.218 0.183 0.221 0.233 ... #>   .. ..$ obs      : num [1:1778] 0.243 0.224 0.185 0.228 0.243 ... #>   .. ..$ obs.lower: num [1:1778] 0.197 0.191 0.16 0.192 0.197 ... #>   .. ..$ obs.upper: num [1:1778] 0.287 0.257 0.219 0.262 0.287 ... #>   ..$ state5:'data.frame':\t1778 obs. of  5 variables: #>   .. ..$ id       : int [1:1778] 2 4 5 7 10 13 14 16 18 19 ... #>   .. ..$ pred     : num [1:1778] 0.148 0.154 0.143 0.144 0.149 ... #>   .. ..$ obs      : num [1:1778] 0.191 0.165 0.222 0.212 0.188 ... #>   .. ..$ obs.lower: num [1:1778] 0.167 0.147 0.184 0.18 0.165 ... #>   .. ..$ obs.upper: num [1:1778] 0.222 0.184 0.268 0.254 0.217 ... #>   ..$ state6:'data.frame':\t1778 obs. of  5 variables: #>   .. ..$ id       : int [1:1778] 2 4 5 7 10 13 14 16 18 19 ... #>   .. ..$ pred     : num [1:1778] 0.189 0.23 0.335 0.264 0.189 ... #>   .. ..$ obs      : num [1:1778] 0.207 0.254 0.316 0.28 0.207 ... #>   .. ..$ obs.lower: num [1:1778] 0.182 0.226 0.275 0.252 0.182 ... #>   .. ..$ obs.upper: num [1:1778] 0.229 0.279 0.353 0.304 0.229 ... #>  $ metadata:List of 8 #>   ..$ valid.transitions   : num [1:6] 1 2 3 4 5 6 #>   ..$ assessed.transitions: num [1:6] 1 2 3 4 5 6 #>   ..$ CI                  : num 95 #>   ..$ CI.R.boot           : num 200 #>   ..$ curve.type          : chr \"rcs\" #>   ..$ j                   : num 1 #>   ..$ s                   : num 0 #>   ..$ t.eval              : num 1826 #>  - attr(*, \"class\")= chr \"calib_blr\""},{"path":"https://alexpate30.github.io/calibmsm/reference/calib_mlr.html","id":null,"dir":"Reference","previous_headings":"","what":"Create data for calibration curves using a multinomial logistic regression framework with inverse probability of censoring weights — calib_mlr","title":"Create data for calibration curves using a multinomial logistic regression framework with inverse probability of censoring weights — calib_mlr","text":"Creates underlying data calibration plots. Observed event probabilities time t.eval estimated inputted predicted transition probabilities tp.pred state j time s. calib_mlr estimates calibration scatter plots using multinomial logistic framework combination landmarking inverse probability censoring weights. Two datasets cohort inidividuals must provided. msdata format dataset generated using mstate package. data.frame one row per individual, relevant variables estimating weights, time censoring varaible (dtcens) indicator (dtcens.s). Weights estimated using cox-proportional hazard model assuming linear functional form variables defined w.covs. urge users specify modwl estimating weights. Confidence intervals calibration scatter plots produced currently unclear present data.","code":""},{"path":"https://alexpate30.github.io/calibmsm/reference/calib_mlr.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Create data for calibration curves using a multinomial logistic regression framework with inverse probability of censoring weights — calib_mlr","text":"","code":"calib_mlr(   data.mstate,   data.raw,   j,   s,   t.eval,   tp.pred,   smoother.type = \"sm.ps\",   ps.int = 4,   degree = 3,   s.df = 4,   niknots = 4,   weights = NULL,   w.function = NULL,   w.covs,   w.landmark.type = \"state\",   w.max = 10,   w.stabilised = FALSE,   w.max.follow = NULL,   ... )"},{"path":"https://alexpate30.github.io/calibmsm/reference/calib_mlr.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Create data for calibration curves using a multinomial logistic regression framework with inverse probability of censoring weights — calib_mlr","text":"data.mstate Validation data msdata format data.raw Validation data data.frame (one row per individual) j Landmark state predictions made s Landmark time predictions made t.eval Follow time calibration assessed tp.pred Vector predicted transition probabilities time t.eval smoother.type Type smoothing applied. Takes values s (see s), sm.ps (see sm.ps) sm.os (see sm.os). ps.int number equally-spaced B spline intervals vector spline smoother (see sm.ps) degree degree B-spline basis vector spline smoother (see sm.ps) s.df degrees freedom vector spline (see s) niknots number interior knots (see sm.os) weights Vector inverse probability censoring weights w.function Custom function estimating inverse probability censoring weights w.covs Character vector variable names adjust calculating inverse probability censoring weights w.landmark.type Whether weights estimated individuals uncensored time s ('') individuals uncensored state j time s ('state') w.max Maximum bound inverse probability censoring weights w.stabilised Indicates whether inverse probability censoring weights stabilised w.max.follow Maximum follow model calculating inverse probability censoring weights. Reducing t.eval + 1 may aid proportional hazards assumption met model. ... Extra arguments passed w.function (custom function estimating weights)","code":""},{"path":"https://alexpate30.github.io/calibmsm/reference/calib_mlr.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Create data for calibration curves using a multinomial logistic regression framework with inverse probability of censoring weights — calib_mlr","text":"Observed event probabilities time t.eval estimated predicted transition probabilities tp.pred state j time s. calib_mlr estimates calibration scatter plots uses technique assessing calibration multinomial logistic regression models, namely nominal calibration framework #' van Hoorde et al. (2014, 2015). Landmarking applied assess calibration individuals uncensored state j time s. Censoring dealt using inverse probability censoring weights. Two datasets cohort inidividuals must provided. Firstly data.mstate must dataset class msdata, generated using [mstate] package. dataset used apply landmarking. Secondly, data.raw must data.frame one row per individual, containing desired variables estimating weights, variables time censoring (dtcens), indicator censoring dtcens.s, (dtcens.s = 1) individual censored time dtcens, dtcens.s = 0 otherwise. individual enters absorbing state, prevents censoring happening (.e. dtcens.s = 0). Unless user specifies weights using weights, weights estimated using cox-proportional hazard model, assuming linear functional form variables defined w.covs. urge users specify model estimating weights. weights argument must vector length equal number rows data.raw. Confidence intervals generated calibration scatter plots. confidence intervals estimated data point, clear plotted cohesively. Calibration plots produced specific transitions (.e. transitions.calib_blr) nominal calibration framework (van Hoorde et al., 2014, 2015) assesses calibration states simultaneously. calibration scatter plots can plotted using plot.calib_mlr. #' @returns calib_mlr returns list containing two elements: plotdata metadata. plotdata element contains data calibration scatter plots list element containing data transition probabilities possible states. list element contains patient ids (id), predicted transition probabilities (pred) estimated observed event probabilities (obs). metadata element contains metadata including vector possible transitions user specified information.","code":""},{"path":"https://alexpate30.github.io/calibmsm/reference/calib_mlr.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Create data for calibration curves using a multinomial logistic regression framework with inverse probability of censoring weights — calib_mlr","text":"","code":"# Estimate calibration scatter plots for the predicted transition # probabilities at time t.eval = 1826, when predictions were made at time # s = 0 in state j = 1. These predicted transition probabilities are stored in tps0.  # Extract the predicted transition probabilities out of state j = 1 tp.pred <- dplyr::select(dplyr::filter(tps0, j == 1), any_of(paste(\"pstate\", 1:6, sep = \"\")))  # Now estimate the observed event probabilities for each possible transition.  dat.calib.mlr <- calib_mlr(data.mstate = msebmtcal,  data.raw = ebmtcal,  j=1,  s=0,  t.eval = 1826,  tp.pred = tp.pred,  w.covs = c(\"year\", \"agecl\", \"proph\", \"match\"))  # The data for each calibration scatter plots are stored in the \"plotdata\" # list element. str(dat.calib.mlr) #> List of 2 #>  $ plotdata:List of 6 #>   ..$ state1:'data.frame':\t1778 obs. of  3 variables: #>   .. ..$ id  : int [1:1778] 2 4 5 7 10 13 14 16 18 19 ... #>   .. ..$ pred: num [1:1778] 0.114 0.1384 0.1233 0.0974 0.1137 ... #>   .. ..$ obs : num [1:1778] 0.092 0.0977 0.0506 0.1051 0.0947 ... #>   ..$ state2:'data.frame':\t1778 obs. of  3 variables: #>   .. ..$ id  : int [1:1778] 2 4 5 7 10 13 14 16 18 19 ... #>   .. ..$ pred: num [1:1778] 0.232 0.184 0.161 0.212 0.232 ... #>   .. ..$ obs : num [1:1778] 0.0963 0.1609 0.0812 0.1076 0.0981 ... #>   ..$ state3:'data.frame':\t1778 obs. of  3 variables: #>   .. ..$ id  : int [1:1778] 2 4 5 7 10 13 14 16 18 19 ... #>   .. ..$ pred: num [1:1778] 0.0844 0.0758 0.0551 0.0615 0.0844 ... #>   .. ..$ obs : num [1:1778] 0.1789 0.1387 0.0772 0.1472 0.1811 ... #>   ..$ state4:'data.frame':\t1778 obs. of  3 variables: #>   .. ..$ id  : int [1:1778] 2 4 5 7 10 13 14 16 18 19 ... #>   .. ..$ pred: num [1:1778] 0.233 0.218 0.183 0.221 0.233 ... #>   .. ..$ obs : num [1:1778] 0.217 0.171 0.351 0.145 0.211 ... #>   ..$ state5:'data.frame':\t1778 obs. of  3 variables: #>   .. ..$ id  : int [1:1778] 2 4 5 7 10 13 14 16 18 19 ... #>   .. ..$ pred: num [1:1778] 0.148 0.154 0.143 0.144 0.149 ... #>   .. ..$ obs : num [1:1778] 0.187 0.202 0.23 0.15 0.182 ... #>   ..$ state6:'data.frame':\t1778 obs. of  3 variables: #>   .. ..$ id  : int [1:1778] 2 4 5 7 10 13 14 16 18 19 ... #>   .. ..$ pred: num [1:1778] 0.189 0.23 0.335 0.264 0.189 ... #>   .. ..$ obs : num [1:1778] 0.229 0.23 0.21 0.345 0.233 ... #>  $ metadata:List of 4 #>   ..$ valid.transitions: Named int [1:6] 1 2 3 4 5 6 #>   .. ..- attr(*, \"names\")= chr [1:6] \"tp.pred1\" \"tp.pred2\" \"tp.pred3\" \"tp.pred4\" ... #>   ..$ j                : num 1 #>   ..$ s                : num 0 #>   ..$ t.eval           : num 1826 #>  - attr(*, \"class\")= chr \"calib_mlr\""},{"path":"https://alexpate30.github.io/calibmsm/reference/calib_pv.html","id":null,"dir":"Reference","previous_headings":"","what":"Estimate calibration curves for a multistate model using pseudo-values. — calib_pv","title":"Estimate calibration curves for a multistate model using pseudo-values. — calib_pv","text":"Creates underlying data calibration curves. calib_pv estimates observed event probabilities given set predicted transition probabilities cohort interest. done using techniques assessing calibration binary logistic regression models, combination inverse probability censoring weights landmarking.","code":""},{"path":"https://alexpate30.github.io/calibmsm/reference/calib_pv.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Estimate calibration curves for a multistate model using pseudo-values. — calib_pv","text":"","code":"calib_pv(   data.mstate,   data.raw,   j,   s,   t.eval,   tp.pred,   curve.type = \"rcs\",   rcs.nk = 3,   loess.span = 0.75,   loess.degree = 2,   group.vars = NULL,   n.pctls = NULL,   CI = FALSE,   CI.type = NULL,   CI.R.boot = NULL,   data.pred.plot = NULL,   transitions.out = NULL )"},{"path":"https://alexpate30.github.io/calibmsm/reference/calib_pv.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Estimate calibration curves for a multistate model using pseudo-values. — calib_pv","text":"data.mstate Validation data msdata format data.raw Validation data data.frame (one row per individual) j Landmark state predictions made s Landmark time predictions made t.eval Follow time calibration assessed tp.pred Matrix predicted transition probabilities time t.eval, state j time s. must seperate column predicted transition probabilities every state, even predicted transition probabilities 0. curve.type Whether calibration curves estimated using restricted cubic splines ('rcs') loess smoothers ('loess') rcs.nk Number knots curves estimated using restricted cubic splines loess.span Span curves estimated using loess smoothers loess.degree Degree curves estimated. using loess smoothers group.vars Baseline variables define groups within estimate pseudo-values n.pctls Number percentiles group individuals respect predicted transition probabilities estimating pseudo-values CI Size confidence intervals % CI.type Way confidence interval calculated (bootstrap parametric) CI.R.boot Number bootstrap replicates estimating confidence interval calibration curve using bootstrapping data.pred.plot Data frame matrix predicted risks possible transition plot calibration curves. Must one column every possible transition. transitions.Transitions calculate calibration curves. possible transitions left NULL.","code":""},{"path":"https://alexpate30.github.io/calibmsm/reference/calib_pv.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Estimate calibration curves for a multistate model using pseudo-values. — calib_pv","text":"calib_pv returns list containing two elements: plotdata metadata. plotdata element contains data calibration curves. list element containing calibration plot data transition probabilities possible states. list element contains patient ids (id) data.raw, predicted transition probabilities (pred) estimated observed event probabilities (obs). confidence interval requested, upper (obs.upper) lower (obs.lower) bounds observed event probabilities also returned. data.pred.plot defined manually, column (id) returned. metadata element contains metadata including: vector possible transitions, vector transitions calibration curves estimated , size confidence interval, method estimating calibration curve user specified information.","code":""},{"path":"https://alexpate30.github.io/calibmsm/reference/calib_pv.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Estimate calibration curves for a multistate model using pseudo-values. — calib_pv","text":"Observed event probabilities time t.eval estimated predicted transition probabilities tp.pred state j time s. calib_pv estimates observed event probabilities using pseudo-values. Calibraiton curves generatd regression pseudo-values transition probabilities predicted transition probabilities. REF XXXX. Currently calibration curves can produced using loess smoothers. updated include restricted cubic splines. XXXX Landmarking applied assess calibration individuals uncensored state j time s. Two datasets cohort inidividuals must provided. Firstly data.mstate must dataset class msdata, generated using [mstate] package. dataset used apply landmarking. Secondly, data.raw must data.frame one row per individual, containing desired variables calculating pseudo-values within (baseline variables required group.vars = NULL). Confidence intervals calibration curves can estimated using bootstrapping. calibration curves can plotted using plot.calib_pv.","code":""},{"path":"https://alexpate30.github.io/calibmsm/reference/calib_pv.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Estimate calibration curves for a multistate model using pseudo-values. — calib_pv","text":"","code":"# Estimate calibration curves for the predicted transition # probabilities at time t.eval = 1826, when predictions were made at time # s = 100 in state j = 3. These predicted transition probabilities are stored in tps100.  # Extract the predicted transition probabilities out of state j = 1 tp.pred <- dplyr::select(dplyr::filter(tps100, j == 3), any_of(paste(\"pstate\", 1:6, sep = \"\")))  # Now estimate the observed event probabilities for each possible transition.  dat.calib.pseudo <- calib_pv(data.mstate = msebmtcal,   data.raw = ebmtcal,   j = 3,   s = 100,   t.eval = 1826,   tp.pred = tp.pred,   group.vars = c(\"year\"),   n.pctls = 2,   loess.span = 0.75, loess.degree = 2)  # The data for each calibration curve are stored in the \"plotdata\" list # element. str(dat.calib.pseudo) #> List of 2 #>  $ plotdata:List of 4 #>   ..$ state3:'data.frame':\t413 obs. of  3 variables: #>   .. ..$ id  : num [1:413] 3 13 18 22 23 24 25 26 27 28 ... #>   .. ..$ pred: num [1:413] 0.537 0.537 0.394 0.43 0.43 ... #>   .. ..$ obs : num [1:413] 0.529 0.529 0.422 0.445 0.445 ... #>   ..$ state4:'data.frame':\t413 obs. of  3 variables: #>   .. ..$ id  : num [1:413] 3 13 18 22 23 24 25 26 27 28 ... #>   .. ..$ pred: num [1:413] 0.1332 0.1334 0.0477 0.0516 0.0516 ... #>   .. ..$ obs : num [1:413] 0.1353 0.1355 0.0521 0.0545 0.0545 ... #>   ..$ state5:'data.frame':\t413 obs. of  3 variables: #>   .. ..$ id  : num [1:413] 3 13 18 22 23 24 25 26 27 28 ... #>   .. ..$ pred: num [1:413] 0.105 0.105 0.133 0.172 0.172 ... #>   .. ..$ obs : num [1:413] 0.134 0.1342 0.1455 0.0879 0.0878 ... #>   ..$ state6:'data.frame':\t413 obs. of  3 variables: #>   .. ..$ id  : num [1:413] 3 13 18 22 23 24 25 26 27 28 ... #>   .. ..$ pred: num [1:413] 0.225 0.225 0.426 0.347 0.347 ... #>   .. ..$ obs : num [1:413] 0.196 0.196 0.585 0.404 0.404 ... #>  $ metadata:List of 11 #>   ..$ valid.transitions   : num [1:4] 3 4 5 6 #>   ..$ assessed.transitions: num [1:4] 3 4 5 6 #>   ..$ curve.type          : chr \"rcs\" #>   ..$ CI                  : logi FALSE #>   ..$ CI.type             : NULL #>   ..$ CI.R.boot           : NULL #>   ..$ j                   : num 3 #>   ..$ s                   : num 100 #>   ..$ t.eval              : num 1826 #>   ..$ group.vars          : chr \"year\" #>   ..$ n.pctls             : num 2 #>  - attr(*, \"class\")= chr \"calib_pv\"  #'"},{"path":"https://alexpate30.github.io/calibmsm/reference/calibmsm-package.html","id":null,"dir":"Reference","previous_headings":"","what":"calibmsm: Calibration plots for the transition probabilities from multistate models — calibmsm-package","title":"calibmsm: Calibration plots for the transition probabilities from multistate models — calibmsm-package","text":"toolbox aid estimation calibration plots multistate models developed. Calibration transition probabilities time t state j time s assessed. done using combination landmarking, calibration methods binary logistic multinomaial logistic regression models inverse probability censoring weights.","code":""},{"path":[]},{"path":"https://alexpate30.github.io/calibmsm/reference/calibmsm-package.html","id":"author","dir":"Reference","previous_headings":"","what":"Author","title":"calibmsm: Calibration plots for the transition probabilities from multistate models — calibmsm-package","text":"Maintainer: Alexander Pate alexander.pate@manchester.ac.uk (ORCID)","code":""},{"path":"https://alexpate30.github.io/calibmsm/reference/ebmtcal.html","id":null,"dir":"Reference","previous_headings":"","what":"European Group for Blood and Marrow Transplantation data — ebmtcal","title":"European Group for Blood and Marrow Transplantation data — ebmtcal","text":"ebmt data format ready assess calibration","code":""},{"path":"https://alexpate30.github.io/calibmsm/reference/ebmtcal.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"European Group for Blood and Marrow Transplantation data — ebmtcal","text":"","code":"ebmtcal"},{"path":[]},{"path":"https://alexpate30.github.io/calibmsm/reference/ebmtcal.html","id":"-ebmtcal-","dir":"Reference","previous_headings":"","what":"'ebmtcal'","title":"European Group for Blood and Marrow Transplantation data — ebmtcal","text":"data frame 2,279 rows 17 columns: id Patient indentifier rec, rec.s Time event indicator recovery variable ae, ae.s Time event indicator adverse event variable recae, recae.s Time event indicator recovery + adverse event variable rel, rel.s Time event indicator relapse variable srv, srv.s Time event indicator death variable year Year transplant agecl Age transplant proph Prophylaxis match Donor-recipient match dtcens Time censoring dtcens.s Event indicator, 1:censoring occured, 0: absorbing state entered censoring occured","code":""},{"path":"https://alexpate30.github.io/calibmsm/reference/ebmtcal.html","id":"source","dir":"Reference","previous_headings":"","what":"Source","title":"European Group for Blood and Marrow Transplantation data — ebmtcal","text":"https://search.r-project.org/CRAN/refmans/mstate/html/EBMT-data.htmlE","code":""},{"path":"https://alexpate30.github.io/calibmsm/reference/msebmtcal.cmprsk.html","id":null,"dir":"Reference","previous_headings":"","what":"European Group for Blood and Marrow Transplantation data in competing risks format, for transitions out of the initial state only — msebmtcal.cmprsk","title":"European Group for Blood and Marrow Transplantation data in competing risks format, for transitions out of the initial state only — msebmtcal.cmprsk","text":"Used vignette: Comparison--graphical-calibration-curves--competing-risks-setting. ebmt data 'msdata' format, derived ebmt dataset using software mstate package. However, transitions initial state considered, making data competing risks model initial state.","code":""},{"path":"https://alexpate30.github.io/calibmsm/reference/msebmtcal.cmprsk.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"European Group for Blood and Marrow Transplantation data in competing risks format, for transitions out of the initial state only — msebmtcal.cmprsk","text":"","code":"msebmtcal.cmprsk"},{"path":[]},{"path":"https://alexpate30.github.io/calibmsm/reference/msebmtcal.cmprsk.html","id":"-msebmtcal-cmprsk-","dir":"Reference","previous_headings":"","what":"'msebmtcal.cmprsk'","title":"European Group for Blood and Marrow Transplantation data in competing risks format, for transitions out of the initial state only — msebmtcal.cmprsk","text":"data frame 9,116 rows 8 columns: id Patient indentifier transition state transition state trans transition number Tstart time entered state '' Tstop time leaving state '' time time state '' status event indicator, 1:transitioned state ''","code":""},{"path":"https://alexpate30.github.io/calibmsm/reference/msebmtcal.html","id":null,"dir":"Reference","previous_headings":"","what":"European Group for Blood and Marrow Transplantation data — msebmtcal","title":"European Group for Blood and Marrow Transplantation data — msebmtcal","text":"ebmt data 'msdata' format, derived ebmt dataset using software mstate package","code":""},{"path":"https://alexpate30.github.io/calibmsm/reference/msebmtcal.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"European Group for Blood and Marrow Transplantation data — msebmtcal","text":"","code":"msebmtcal"},{"path":[]},{"path":"https://alexpate30.github.io/calibmsm/reference/msebmtcal.html","id":"-msebmtcal-","dir":"Reference","previous_headings":"","what":"'msebmtcal'","title":"European Group for Blood and Marrow Transplantation data — msebmtcal","text":"data frame 15,512 rows 8 columns: id Patient indentifier transition state transition state trans transition number Tstart time entered state '' Tstop time leaving state '' time time state '' status event indicator, 1:transitioned state ''","code":""},{"path":"https://alexpate30.github.io/calibmsm/reference/plot.calib_blr.html","id":null,"dir":"Reference","previous_headings":"","what":"Plots calibration curves estimated using calib_blr. — plot.calib_blr","title":"Plots calibration curves estimated using calib_blr. — plot.calib_blr","text":"Plots calibration curves transition probabilities multistate model using data estimated calib_blr.","code":""},{"path":"https://alexpate30.github.io/calibmsm/reference/plot.calib_blr.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Plots calibration curves estimated using calib_blr. — plot.calib_blr","text":"","code":"# S3 method for calib_blr plot(x, ..., combine = TRUE, ncol = NULL, nrow = NULL)"},{"path":"https://alexpate30.github.io/calibmsm/reference/plot.calib_blr.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Plots calibration curves estimated using calib_blr. — plot.calib_blr","text":"x Object class 'calib_blr' generated calib_blr. ... combine Whether combine one plot using ggarrange, return list individual plots ncol Number columns combined calibration plot nrow Number rows combined calibration plot","code":""},{"path":"https://alexpate30.github.io/calibmsm/reference/plot.calib_blr.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Plots calibration curves estimated using calib_blr. — plot.calib_blr","text":"combine = TRUE, returns object classes gg, ggplot, ggarrange, ggplots combined one object. combine = FALSE, returns object class list, element containing object class gg ggplot.","code":""},{"path":"https://alexpate30.github.io/calibmsm/reference/plot.calib_mlr.html","id":null,"dir":"Reference","previous_headings":"","what":"Plots calibration scatter plots estimated using calib_mlr. — plot.calib_mlr","title":"Plots calibration scatter plots estimated using calib_mlr. — plot.calib_mlr","text":"Plots calibration scatter plots transition probabilities multistate model using data estimated calib_mlr.","code":""},{"path":"https://alexpate30.github.io/calibmsm/reference/plot.calib_mlr.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Plots calibration scatter plots estimated using calib_mlr. — plot.calib_mlr","text":"","code":"# S3 method for calib_mlr plot(x, ..., combine = TRUE, ncol = NULL, nrow = NULL)"},{"path":"https://alexpate30.github.io/calibmsm/reference/plot.calib_mlr.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Plots calibration scatter plots estimated using calib_mlr. — plot.calib_mlr","text":"x Object class 'calib_mlr' generated calib_mlr ... combine Whether combine one plot using ggarrange, return list individual plots ncol Number columns combined calibration plot nrow Number rows combined calibration plot","code":""},{"path":"https://alexpate30.github.io/calibmsm/reference/plot.calib_mlr.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Plots calibration scatter plots estimated using calib_mlr. — plot.calib_mlr","text":"combine = TRUE, returns object classes gg, ggplot, ggarrange, ggplots combined one object. combine = FALSE, returns object class list, element containing object class gg ggplot.","code":""},{"path":"https://alexpate30.github.io/calibmsm/reference/plot.calib_pv.html","id":null,"dir":"Reference","previous_headings":"","what":"Plots calibration curves estimated using calib_pv. — plot.calib_pv","title":"Plots calibration curves estimated using calib_pv. — plot.calib_pv","text":"Plots calibration curves transition probabilities multistate model using data estimated calib_pv.","code":""},{"path":"https://alexpate30.github.io/calibmsm/reference/plot.calib_pv.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Plots calibration curves estimated using calib_pv. — plot.calib_pv","text":"","code":"# S3 method for calib_pv plot(x, ..., combine = TRUE, ncol = NULL, nrow = NULL)"},{"path":"https://alexpate30.github.io/calibmsm/reference/plot.calib_pv.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Plots calibration curves estimated using calib_pv. — plot.calib_pv","text":"x Object class 'calib_pseudo' generated calib_pv. ... combine Whether combine one plot using ggarrange, return list individual plots ncol Number columns combined calibration plot nrow Number rows combined calibration plot","code":""},{"path":"https://alexpate30.github.io/calibmsm/reference/plot.calib_pv.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Plots calibration curves estimated using calib_pv. — plot.calib_pv","text":"combine = TRUE, returns object classes gg, ggplot, ggarrange, ggplots combined one object. combine = FALSE, returns object class list, element containing object class gg ggplot.","code":""},{"path":"https://alexpate30.github.io/calibmsm/reference/tp.cmprsk.j0.html","id":null,"dir":"Reference","previous_headings":"","what":"Predicted risks for a competing risks model out of state j = 0 — tp.cmprsk.j0","title":"Predicted risks for a competing risks model out of state j = 0 — tp.cmprsk.j0","text":"Used vignette: Comparison--graphical-calibration-curves--competing-risks-setting. predicted transition probabilities made state j = 1 time s = 0, treat states absorbing states.","code":""},{"path":"https://alexpate30.github.io/calibmsm/reference/tp.cmprsk.j0.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Predicted risks for a competing risks model out of state j = 0 — tp.cmprsk.j0","text":"","code":"tp.cmprsk.j0"},{"path":[]},{"path":"https://alexpate30.github.io/calibmsm/reference/tp.cmprsk.j0.html","id":"-tp-cmprsk-j-","dir":"Reference","previous_headings":"","what":"'tp.cmprsk.j0'","title":"Predicted risks for a competing risks model out of state j = 0 — tp.cmprsk.j0","text":"data frame 2,279 rows 13 columns: id Patient indentifier pstate1, pstate2, pstate3, pstate4, pstate5, pstate6 Predicted transition probabilities transitions states 1 6 se1, se2, se3, se4, se5, se6 Standard error predicted transition probabilities transitions states 1 6","code":""},{"path":"https://alexpate30.github.io/calibmsm/reference/tps0.html","id":null,"dir":"Reference","previous_headings":"","what":"Predicted transition probabilities out of every state at time s = 0 — tps0","title":"Predicted transition probabilities out of every state at time s = 0 — tps0","text":"Predicted transition probabilities every state time s = 0","code":""},{"path":"https://alexpate30.github.io/calibmsm/reference/tps0.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Predicted transition probabilities out of every state at time s = 0 — tps0","text":"","code":"tps0"},{"path":[]},{"path":"https://alexpate30.github.io/calibmsm/reference/tps0.html","id":"-tps-","dir":"Reference","previous_headings":"","what":"'tps0'","title":"Predicted transition probabilities out of every state at time s = 0 — tps0","text":"data frame 13,674 rows 14 columns: id Patient indentifier pstate1, pstate2, pstate3, pstate4, pstate5, pstate6 Predicted transition probabilities transitions states 1 6 se1, se2, se3, se4, se5, se6 Standard error predicted transition probabilities transitions states 1 6 j State predicted transition probabilities estimated ","code":""},{"path":"https://alexpate30.github.io/calibmsm/reference/tps100.html","id":null,"dir":"Reference","previous_headings":"","what":"Predicted transition probabilities out of every state at time s = 100 — tps100","title":"Predicted transition probabilities out of every state at time s = 100 — tps100","text":"Predicted transition probabilities every state time s = 100","code":""},{"path":"https://alexpate30.github.io/calibmsm/reference/tps100.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Predicted transition probabilities out of every state at time s = 100 — tps100","text":"","code":"tps100"},{"path":[]},{"path":"https://alexpate30.github.io/calibmsm/reference/tps100.html","id":"-tps-","dir":"Reference","previous_headings":"","what":"'tps100'","title":"Predicted transition probabilities out of every state at time s = 100 — tps100","text":"data frame 13,674 rows 14 columns: id Patient indentifier pstate1, pstate2, pstate3, pstate4, pstate5, pstate6 Predicted transition probabilities transitions states 1 6 se1, se2, se3, se4, se5, se6 Standard error predicted transition probabilities transitions states 1 6 j State predicted transition probabilities estimated ","code":""}]
